.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Graph::Easy::Group 3"
.TH Graph::Easy::Group 3 "2014-04-12" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Graph::Easy::Group \- A group of nodes (aka subgraph) in Graph::Easy
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Graph::Easy;
\&
\&        my $bonn = Graph::Easy::Node\->new(\*(AqBonn\*(Aq);
\&
\&        $bonn\->set_attribute(\*(Aqborder\*(Aq, \*(Aqsolid 1px black\*(Aq);
\&
\&        my $berlin = Graph::Easy::Node\->new( name => \*(AqBerlin\*(Aq );
\&
\&        my $cities = Graph::Easy::Group\->new(
\&                name => \*(AqCities\*(Aq,
\&        );
\&        $cities\->set_attribute(\*(Aqborder\*(Aq, \*(Aqdashed 1px blue\*(Aq);
\&
\&        $cities\->add_nodes ($bonn);
\&        # $bonn will be ONCE in the group
\&        $cities\->add_nodes ($bonn, $berlin);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \f(CW\*(C`Graph::Easy::Group\*(C'\fR represents a group of nodes in an \f(CW\*(C`Graph::Easy\*(C'\fR
object. These nodes are grouped together on output.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 1
\&        my $group = Graph::Easy::Group\->new( $options );
.Ve
.PP
Create a new, empty group. \f(CW$options\fR are the possible options, see
Graph::Easy::Node for a list.
.SS "\fIerror()\fP"
.IX Subsection "error()"
.Vb 1
\&        $last_error = $group\->error();
\&
\&        $group\->error($error);                  # set new messags
\&        $group\->error(\*(Aq\*(Aq);                      # clear error
.Ve
.PP
Returns the last error message, or '' for no error.
.SS "\fIas_ascii()\fP"
.IX Subsection "as_ascii()"
.Vb 1
\&        my $ascii = $group\->as_ascii();
.Ve
.PP
Return the group as a little box drawn in \s-1ASCII\s0 art as a string.
.SS "\fIname()\fP"
.IX Subsection "name()"
.Vb 1
\&        my $name = $group\->name();
.Ve
.PP
Return the name of the group.
.SS "\fIid()\fP"
.IX Subsection "id()"
.Vb 1
\&        my $id = $group\->id();
.Ve
.PP
Returns the group's unique \s-1ID\s0 number.
.SS "\fIset_attribute()\fP"
.IX Subsection "set_attribute()"
.Vb 1
\&        $group\->set_attribute(\*(Aqborder\-style\*(Aq, \*(Aqnone\*(Aq);
.Ve
.PP
Sets the specified attribute of this (and only this!) group to the
specified value.
.SS "\fIadd_member()\fP"
.IX Subsection "add_member()"
.Vb 2
\&        $group\->add_member($node);
\&        $group\->add_member($group);
.Ve
.PP
Add the specified object to this group and returns this member. If the
passed argument is a scalar, will treat it as a node name.
.PP
Note that each object can only be a member of one group at a time.
.SS "\fIadd_node()\fP"
.IX Subsection "add_node()"
.Vb 1
\&        $group\->add_node($node);
.Ve
.PP
Add the specified node to this group and returns this node.
.PP
Note that each object can only be a member of one group at a time.
.SS "\fIadd_edge()\fP, \fIadd_edge_once()\fP"
.IX Subsection "add_edge(), add_edge_once()"
.Vb 4
\&        $group\->add_edge($edge);                # Graph::Easy::Edge
\&        $group\->add_edge($from, $to);           # Graph::Easy::Node or
\&                                                # Graph::Easy::Group
\&        $group\->add_edge(\*(AqFrom\*(Aq, \*(AqTo\*(Aq);         # Scalars
.Ve
.PP
If passed an Graph::Easy::Edge object, moves the nodes involved in
this edge to the group.
.PP
if passed two nodes, adds these nodes to the graph (unless they already
exist) and adds an edge between these two nodes. See \fIadd_edge_once()\fR
to avoid creating multiple edges.
.PP
This method works only on groups that are part of a graph.
.PP
Note that each object can only be a member of one group at a time,
and edges are automatically a member of a group if and only if both
the target and the destination node are a member of the same group.
.SS "\fIadd_group()\fP"
.IX Subsection "add_group()"
.Vb 2
\&        my $inner = $group\->add_group(\*(AqGroup name\*(Aq);
\&        my $nested = $group\->add_group($group);
.Ve
.PP
Add a group as subgroup to this group and returns this group.
.SS "\fIdel_member()\fP"
.IX Subsection "del_member()"
.Vb 2
\&        $group\->del_member($node);
\&        $group\->del_member($group);
.Ve
.PP
Delete the specified object from this group.
.SS "\fIdel_node()\fP"
.IX Subsection "del_node()"
.Vb 1
\&        $group\->del_node($node);
.Ve
.PP
Delete the specified node from this group.
.SS "\fIdel_edge()\fP"
.IX Subsection "del_edge()"
.Vb 1
\&        $group\->del_edge($edge);
.Ve
.PP
Delete the specified edge from this group.
.SS "\fIadd_nodes()\fP"
.IX Subsection "add_nodes()"
.Vb 1
\&        $group\->add_nodes($node, $node2, ... );
.Ve
.PP
Add all the specified nodes to this group and returns them as a list.
.SS "\fInodes()\fP"
.IX Subsection "nodes()"
.Vb 1
\&        my @nodes = $group\->nodes();
.Ve
.PP
Returns a list of all node objects that belong to this group.
.SS "\fIedges()\fP"
.IX Subsection "edges()"
.Vb 1
\&        my @edges = $group\->edges();
.Ve
.PP
Returns a list of all edge objects that lead to or from this group.
.PP
Note: This does \fBnot\fR return edges between nodes that are inside the group,
for this see \fIedges_within()\fR.
.SS "\fIedges_within()\fP"
.IX Subsection "edges_within()"
.Vb 1
\&        my @edges_within = $group\->edges_within();
.Ve
.PP
Returns a list of all edge objects that are \fIinside\fR this group, in arbitrary
order. Edges are automatically considered \fIinside\fR a group if their starting
and ending node both are in the same group.
.PP
Note: This does \fBnot\fR return edges between this group and other groups,
nor edges between this group and nodes outside this group, for this see
\&\fIedges()\fR.
.SS "\fIgroups()\fP"
.IX Subsection "groups()"
.Vb 1
\&        my @groups = $group\->groups();
.Ve
.PP
Returns the contained groups of this group as Graph::Easy::Group objects,
in arbitrary order.
.SS "\fIgroups_within()\fP"
.IX Subsection "groups_within()"
.Vb 3
\&        # equivalent to $group\->groups():
\&        my @groups = $group\->groups_within();           # all
\&        my @toplevel_groups = $group\->groups_within(0); # level 0 only
.Ve
.PP
Return the groups that are inside this group, up to the specified level,
in arbitrary order.
.PP
The default level is \-1, indicating no bounds and thus all contained
groups are returned.
.PP
A level of 0 means only the direct children, and hence only the toplevel
groups will be returned. A level 1 means the toplevel groups and their
toplevel children, and so on.
.SS "\fIas_txt()\fP"
.IX Subsection "as_txt()"
.Vb 1
\&        my $txt = $group\->as_txt();
.Ve
.PP
Returns the group as Graph::Easy textual description.
.SS "\fI_find_label_cell()\fP"
.IX Subsection "_find_label_cell()"
.Vb 1
\&        $group\->_find_label_cell();
.Ve
.PP
Called by the layouter once for each group. Goes through all cells of this
group and finds one where to attach the label to. Internal usage only.
.SS "\fIget_attributes()\fP"
.IX Subsection "get_attributes()"
.Vb 1
\&        my $att = $object\->get_attributes();
.Ve
.PP
Return all effective attributes on this object (graph/node/group/edge) as
an anonymous hash ref. This respects inheritance and default values.
.PP
See also \fIraw_attributes()\fR.
.SS "\fIraw_attributes()\fP"
.IX Subsection "raw_attributes()"
.Vb 1
\&        my $att = $object\->get_attributes();
.Ve
.PP
Return all set attributes on this object (graph/node/group/edge) as
an anonymous hash ref. This respects inheritance, but does not include
default values for unset attributes.
.PP
See also \fIget_attributes()\fR.
.SS "attribute related methods"
.IX Subsection "attribute related methods"
You can call all the various attribute related methods like \f(CW\*(C`set_attribute()\*(C'\fR,
\&\f(CW\*(C`get_attribute()\*(C'\fR, etc. on a group, too. For example:
.PP
.Vb 2
\&        $group\->set_attribute(\*(Aqlabel\*(Aq, \*(Aqby train\*(Aq);
\&        my $attr = $group\->get_attributes();
.Ve
.PP
You can find more documentation in Graph::Easy.
.SS "\fIlayout()\fP"
.IX Subsection "layout()"
This routine should not be called on groups, it only works on the graph
itself.
.SS "\fIshape()\fP"
.IX Subsection "shape()"
.Vb 1
\&        my $shape = $group\->shape();
.Ve
.PP
Returns the shape of the group as string.
.SS "\fIhas_as_successor()\fP"
.IX Subsection "has_as_successor()"
.Vb 4
\&        if ($group\->has_as_successor($other))
\&          {
\&          ...
\&          }
.Ve
.PP
Returns true if \f(CW$other\fR (a node or group) is a successor of this group, e.g.
if there is an edge leading from this group to \f(CW$other\fR.
.SS "\fIhas_as_predecessor()\fP"
.IX Subsection "has_as_predecessor()"
.Vb 4
\&        if ($group\->has_as_predecessor($other))
\&          {
\&          ...
\&          }
.Ve
.PP
Returns true if the group has \f(CW$other\fR (a group or node) as predecessor, that
is if there is an edge leading from \f(CW$other\fR to this group.
.SS "\fIroot_node()\fP"
.IX Subsection "root_node()"
.Vb 1
\&        my $root = $group\->root_node();
.Ve
.PP
Return the root node as Graph::Easy::Node object, if it was
set with the 'root' attribute.
.SH "EXPORT"
.IX Header "EXPORT"
None by default.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Graph::Easy, Graph::Easy::Node, Graph::Easy::Manual.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 2004 \- 2008 by Tels <http://bloodgate.com>
.PP
See the \s-1LICENSE\s0 file for more details.
