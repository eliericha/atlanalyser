.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Graph::Easy::Parser::VCG 3"
.TH Graph::Easy::Parser::VCG 3 "2014-04-12" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Graph::Easy::Parser::VCG \- Parse VCG or GDL text into Graph::Easy
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        # creating a graph from a textual description
\&
\&        use Graph::Easy::Parser::VCG;
\&        my $parser = Graph::Easy::Parser::VCG\->new();
\&
\&        my $graph = $parser\->from_text(
\&                "graph: { \en" .
\&                "       node: { title: "Bonn" }\en" .
\&                "       node: { title: "Berlin" }\en" .
\&                "       edge: { sourcename: "Bonn" targetname: "Berlin" }\en" .
\&                "}\en"
\&        );
\&        print $graph\->as_ascii();
\&
\&        print $parser\->from_file(\*(Aqmygraph.vcg\*(Aq)\->as_ascii();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Graph::Easy::Parser::VCG\*(C'\fR parses the text format from the \s-1VCG\s0 or \s-1GDL
\&\s0(Graph Description Language) use by tools like \s-1GCC\s0 and AiSee, and
constructs a \f(CW\*(C`Graph::Easy\*(C'\fR object from it.
.PP
The resulting object can then be used to layout and output the graph
in various formats.
.SS "Output"
.IX Subsection "Output"
The output will be a Graph::Easy object (unless overrriden
with \f(CW\*(C`use_class()\*(C'\fR), see the documentation for Graph::Easy what you can do
with it.
.SS "Attributes"
.IX Subsection "Attributes"
Attributes will be remapped to the proper Graph::Easy attribute names and
values, as much as possible.
.PP
Anything else will be converted to custom attributes starting with \*(L"x\-vcg\-\*(R".
So \*(L"dirty_edge_labels: yes\*(R" will become \*(L"x\-vcg\-dirty_edge_labels: yes\*(R".
.SH "METHODS"
.IX Header "METHODS"
\&\f(CW\*(C`Graph::Easy::Parser::VCG\*(C'\fR supports the same methods
as its parent class \f(CW\*(C`Graph::Easy::Parser\*(C'\fR:
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 2
\&        use Graph::Easy::Parser::VCG;
\&        my $parser = Graph::Easy::Parser::VCG\->new();
.Ve
.PP
Creates a new parser object. There are two valid parameters:
.PP
.Vb 2
\&        debug
\&        fatal_errors
.Ve
.PP
Both take either a false or a true value.
.PP
.Vb 2
\&        my $parser = Graph::Easy::Parser::VCG\->new( debug => 1 );
\&        $parser\->from_text(\*(Aqgraph: { }\*(Aq);
.Ve
.SS "\fIreset()\fP"
.IX Subsection "reset()"
.Vb 1
\&        $parser\->reset();
.Ve
.PP
Reset the status of the parser, clear errors etc. Automatically called
when you call any of the \f(CW\*(C`from_XXX()\*(C'\fR methods below.
.SS "\fIuse_class()\fP"
.IX Subsection "use_class()"
.Vb 1
\&        $parser\->use_class(\*(Aqnode\*(Aq, \*(AqGraph::Easy::MyNode\*(Aq);
.Ve
.PP
Override the class to be used to constructs objects while parsing.
.PP
See Graph::Easy::Parser for further information.
.SS "\fIfrom_text()\fP"
.IX Subsection "from_text()"
.Vb 1
\&        my $graph = $parser\->from_text( $text );
.Ve
.PP
Create a Graph::Easy object from the textual description in \f(CW$text\fR.
.PP
Returns undef for error, you can find out what the error was
with \fIerror()\fR.
.PP
This method will reset any previous error, and thus the \f(CW$parser\fR object
can be re-used to parse different texts by just calling \f(CW\*(C`from_text()\*(C'\fR
multiple times.
.SS "\fIfrom_file()\fP"
.IX Subsection "from_file()"
.Vb 2
\&        my $graph = $parser\->from_file( $filename );
\&        my $graph = Graph::Easy::Parser::VCG\->from_file( $filename );
.Ve
.PP
Creates a Graph::Easy object from the textual description in the file
\&\f(CW$filename\fR.
.PP
The second calling style will create a temporary parser object,
parse the file and return the resulting \f(CW\*(C`Graph::Easy\*(C'\fR object.
.PP
Returns undef for error, you can find out what the error was
with \fIerror()\fR when using the first calling style.
.SS "\fIerror()\fP"
.IX Subsection "error()"
.Vb 1
\&        my $error = $parser\->error();
.Ve
.PP
Returns the last error, or the empty string if no error occured.
.SS "\fIparse_error()\fP"
.IX Subsection "parse_error()"
.Vb 1
\&        $parser\->parse_error( $msg_nr, @params);
.Ve
.PP
Sets an error message from a message number and replaces embedded
templates like \f(CW\*(C`##param1##\*(C'\fR with the passed parameters.
.SH "CAVEATS"
.IX Header "CAVEATS"
The parser has problems with the following things:
.IP "attributes" 12
.IX Item "attributes"
Some attributes are \fBnot\fR remapped properly to what Graph::Easy expects, thus
losing information, either because Graph::Easy doesn't support this feature
yet, or because the mapping is incomplete.
.IP "comments" 12
.IX Item "comments"
Comments written in the source code itself are discarded. If you want to have
comments on the graph, clusters, nodes or edges, use the attribute \f(CW\*(C`comment\*(C'\fR.
These are correctly read in and stored, and then output into the different
formats, too.
.SH "EXPORT"
.IX Header "EXPORT"
Exports nothing.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Graph::Easy, Graph::Write::VCG.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 2005 \- 2008 by Tels <http://bloodgate.com>
.PP
See the \s-1LICENSE\s0 file for information.
