.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Graph::Easy::Edge 3"
.TH Graph::Easy::Edge 3 "2014-04-12" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Graph::Easy::Edge \- An edge (a path connecting one ore more nodes)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Graph::Easy;
\&
\&        my $ssl = Graph::Easy::Edge\->new(
\&                label => \*(Aqencrypted connection\*(Aq,
\&                style => \*(Aqsolid\*(Aq,
\&        );
\&        $ssl\->set_attribute(\*(Aqcolor\*(Aq, \*(Aqred\*(Aq);
\&
\&        my $src = Graph::Easy::Node\->new(\*(Aqsource\*(Aq);
\&
\&        my $dst = Graph::Easy::Node\->new(\*(Aqdestination\*(Aq);
\&
\&        $graph = Graph::Easy\->new();
\&
\&        $graph\->add_edge($src, $dst, $ssl);
\&
\&        print $graph\->as_ascii();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \f(CW\*(C`Graph::Easy::Edge\*(C'\fR represents an edge between two (or more) nodes in a
simple graph.
.PP
Each edge has a direction (from source to destination, or back and forth),
plus a style (line width and style), colors etc. It can also have a label,
e.g. a text associated with it.
.PP
During the layout phase, each edge also contains a list of path-elements
(also called cells), which make up the path from source to destination.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fIerror()\fP"
.IX Subsection "error()"
.Vb 1
\&        $last_error = $edge\->error();
\&
\&        $cvt\->error($error);                    # set new messags
\&        $cvt\->error(\*(Aq\*(Aq);                        # clear error
.Ve
.PP
Returns the last error message, or '' for no error.
.SS "\fIas_ascii()\fP"
.IX Subsection "as_ascii()"
.Vb 1
\&        my $ascii = $edge\->as_ascii();
.Ve
.PP
Returns the edge as a little ascii representation.
.SS "\fIas_txt()\fP"
.IX Subsection "as_txt()"
.Vb 1
\&        my $txt = $edge\->as_txt();
.Ve
.PP
Returns the edge as a little Graph::Easy textual representation.
.SS "\fIlabel()\fP"
.IX Subsection "label()"
.Vb 1
\&        my $label = $edge\->label();
.Ve
.PP
Returns the label (also known as 'name') of the edge.
.SS "\fIname()\fP"
.IX Subsection "name()"
.Vb 1
\&        my $label = $edge\->name();
.Ve
.PP
To make the interface more consistent, the \f(CW\*(C`name()\*(C'\fR method of
an edge can also be called, and it will returned either the edge
label, or the empty string if the edge doesn't have a label.
.SS "\fIstyle()\fP"
.IX Subsection "style()"
.Vb 1
\&        my $style = $edge\->style();
.Ve
.PP
Returns the style of the edge, like 'solid', 'dotted', 'double', etc.
.SS "\fInodes()\fP"
.IX Subsection "nodes()"
.Vb 1
\&        my @nodes = $edge\->nodes();
.Ve
.PP
Returns the source and target node that this edges connects as objects.
.SS "\fIbidirectional()\fP"
.IX Subsection "bidirectional()"
.Vb 4
\&        $edge\->bidirectional(1);
\&        if ($edge\->bidirectional())
\&          {
\&          }
.Ve
.PP
Returns true if the edge is bidirectional, aka has arrow heads on both ends.
An optional parameter will set the bidirectional status of the edge.
.SS "\fIundirected()\fP"
.IX Subsection "undirected()"
.Vb 4
\&        $edge\->undirected(1);
\&        if ($edge\->undirected())
\&          {
\&          }
.Ve
.PP
Returns true if the edge is undirected, aka has now arrow at all.
An optional parameter will set the undirected status of the edge.
.SS "\fIhas_ports()\fP"
.IX Subsection "has_ports()"
.Vb 4
\&        if ($edge\->has_ports())
\&          {
\&          ...
\&          }
.Ve
.PP
Return true if the edge has restriction on the starting or ending
port, e.g. either the \f(CW\*(C`start\*(C'\fR or \f(CW\*(C`end\*(C'\fR attribute is set on
this edge.
.SS "\fIstart_port()\fP"
.IX Subsection "start_port()"
.Vb 1
\&        my $port = $edge\->start_port();
.Ve
.PP
Return undef if the edge does not have a fixed start port, otherwise
returns the port as \*(L"side, number\*(R", for example \*(L"south, 0\*(R".
.SS "\fIend_port()\fP"
.IX Subsection "end_port()"
.Vb 1
\&        my $port = $edge\->end_port();
.Ve
.PP
Return undef if the edge does not have a fixed end port, otherwise
returns the port as \*(L"side, number\*(R", for example \*(L"south, 0\*(R".
.SS "\fIfrom()\fP"
.IX Subsection "from()"
.Vb 1
\&        my $from = $edge\->from();
.Ve
.PP
Returns the node that this edge starts at. See also \f(CW\*(C`to()\*(C'\fR.
.SS "\fIto()\fP"
.IX Subsection "to()"
.Vb 1
\&        my $to = $edge\->to();
.Ve
.PP
Returns the node that this edge leads to. See also \f(CW\*(C`from()\*(C'\fR.
.SS "\fIstart_at()\fP"
.IX Subsection "start_at()"
.Vb 2
\&        $edge\->start_at($other);
\&        my $other = $edge\->start_at(\*(Aqsome node\*(Aq);
.Ve
.PP
Set the edge's start point to the given node. If given a node name,
will add that node to the graph first.
.PP
Returns the new edge start point node.
.SS "\fIend_at()\fP"
.IX Subsection "end_at()"
.Vb 2
\&        $edge\->end_at($other);
\&        my $other = $edge\->end_at(\*(Aqsome other node\*(Aq);
.Ve
.PP
Set the edge's end point to the given node. If given a node name,
will add that node to the graph first.
.PP
Returns the new edge end point node.
.SS "\fIflip()\fP"
.IX Subsection "flip()"
.Vb 1
\&        $edge\->flip();
.Ve
.PP
Swaps the \f(CW\*(C`start\*(C'\fR and \f(CW\*(C`end\*(C'\fR nodes on this edge, e.g. reverses the direction
of the edge.
.PP

.IX Xref "transpose"
.SS "\fIflow()\fP"
.IX Subsection "flow()"
.Vb 1
\&        my $flow = $edge\->flow();
.Ve
.PP
Returns the flow for this edge, honoring inheritance. An edge without
a specific flow set will inherit the flow from the node it comes from.
.SS "\fIedge_flow()\fP"
.IX Subsection "edge_flow()"
.Vb 1
\&        my $flow = $edge\->edge_flow();
.Ve
.PP
Returns the flow for this edge, or undef if it has none set on either
the object itself or its class.
.SS "\fIport()\fP"
.IX Subsection "port()"
.Vb 2
\&        my ($side, $number) = $edge\->port(\*(Aqstart\*(Aq);
\&        my ($side, $number) = $edge\->port(\*(Aqend\*(Aq);
.Ve
.PP
Return the side and port number where this edge starts or ends.
.PP
Returns undef for \f(CW$side\fR if the edge has no port restriction. The
returned side will be one absolute direction of \f(CW\*(C`east\*(C'\fR, \f(CW\*(C`west\*(C'\fR,
\&\f(CW\*(C`north\*(C'\fR or \f(CW\*(C`south\*(C'\fR, depending on the port restriction and
flow at that edge.
.SS "\fIget_attributes()\fP"
.IX Subsection "get_attributes()"
.Vb 1
\&        my $att = $object\->get_attributes();
.Ve
.PP
Return all effective attributes on this object (graph/node/group/edge) as
an anonymous hash ref. This respects inheritance and default values.
.PP
See also \fIraw_attributes()\fR.
.SS "\fIraw_attributes()\fP"
.IX Subsection "raw_attributes()"
.Vb 1
\&        my $att = $object\->get_attributes();
.Ve
.PP
Return all set attributes on this object (graph/node/group/edge) as
an anonymous hash ref. This respects inheritance, but does not include
default values for unset attributes.
.PP
See also \fIget_attributes()\fR.
.SS "attribute related methods"
.IX Subsection "attribute related methods"
You can call all the various attribute related methods like \f(CW\*(C`set_attribute()\*(C'\fR,
\&\f(CW\*(C`get_attribute()\*(C'\fR, etc. on an edge, too. For example:
.PP
.Vb 3
\&        $edge\->set_attribute(\*(Aqlabel\*(Aq, \*(Aqby train\*(Aq);
\&        my $attr = $edge\->get_attributes();
\&        my $raw_attr = $edge\->raw_attributes();
.Ve
.PP
You can find more documentation in Graph::Easy.
.SH "EXPORT"
.IX Header "EXPORT"
None by default.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Graph::Easy.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 2004 \- 2008 by Tels <http://bloodgate.com>.
.PP
See the \s-1LICENSE\s0 file for more details.
