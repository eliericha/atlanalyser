.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Graph::Easy::Node 3"
.TH Graph::Easy::Node 3 "2014-04-12" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Graph::Easy::Node \- Represents a node in a Graph::Easy graph
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Graph::Easy::Node;
\&
\&        my $bonn = Graph::Easy::Node\->new(\*(AqBonn\*(Aq);
\&
\&        $bonn\->set_attribute(\*(Aqborder\*(Aq, \*(Aqsolid 1px black\*(Aq);
\&
\&        my $berlin = Graph::Easy::Node\->new( name => \*(AqBerlin\*(Aq );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \f(CW\*(C`Graph::Easy::Node\*(C'\fR represents a node in a simple graph. Each
node has contents (a text, an image or another graph), and dimension plus
an origin. The origin is typically determined by a graph layouter module
like Graph::Easy.
.SH "METHODS"
.IX Header "METHODS"
Apart from the methods of the base class Graph::Easy::Base, a
\&\f(CW\*(C`Graph::Easy::Node\*(C'\fR has the following methods:
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 2
\&        my $node = Graph::Easy::Node\->new( name => \*(Aqnode name\*(Aq );
\&        my $node = Graph::Easy::Node\->new( \*(Aqnode name\*(Aq );
.Ve
.PP
Creates a new node. If you want to add the node to a Graph::Easy object,
then please use the following to create the node object:
.PP
.Vb 1
\&        my $node = $graph\->add_node(\*(AqNode name\*(Aq);
.Ve
.PP
You can then use \f(CW\*(C`$node\->set_attribute();\*(C'\fR
or \f(CW\*(C`$node\->set_attributes();\*(C'\fR to set the new Node's attributes.
.SS "\fIas_ascii()\fP"
.IX Subsection "as_ascii()"
.Vb 1
\&        my $ascii = $node\->as_ascii();
.Ve
.PP
Return the node as a little box drawn in \s-1ASCII\s0 art as a string.
.SS "\fIas_txt()\fP"
.IX Subsection "as_txt()"
.Vb 1
\&        my $txt = $node\->as_txt();
.Ve
.PP
Return the node in simple txt format, including attributes.
.SS "\fIas_svg()\fP"
.IX Subsection "as_svg()"
.Vb 1
\&        my $svg = $node\->as_svg();
.Ve
.PP
Returns the node as Scalable Vector Graphic. The actual code for
that routine is defined Graph::Easy::As_svg.pm.
.SS "\fIas_graphviz()\fP"
.IX Subsection "as_graphviz()"
\&\fBFor internal use\fR mostly \- use at your own risk.
.PP
.Vb 1
\&        my $txt = $node\->as_graphviz();
.Ve
.PP
Returns the node as graphviz compatible text which can be fed
to dot etc to create images.
.PP
One needs to load Graph::Easy::As_graphviz first before this method
can be called.
.SS "\fIas_graphviz_txt()\fP"
.IX Subsection "as_graphviz_txt()"
\&\fBFor internal use\fR mostly \- use at your own risk.
.PP
.Vb 1
\&        my $txt = $node\->as_graphviz_txt();
.Ve
.PP
Return only the node itself (without attributes) as a graphviz representation.
.PP
One needs to load Graph::Easy::As_graphviz first before this method
can be called.
.SS "\fIas_pure_txt()\fP"
.IX Subsection "as_pure_txt()"
.Vb 1
\&        my $txt = $node\->as_pure_txt();
.Ve
.PP
Return the node in simple txt format, without the attributes.
.SS "\fItext_styles_as_css()\fP"
.IX Subsection "text_styles_as_css()"
.Vb 1
\&        my $styles = $graph\->text_styles_as_css();      # or $edge\->...() etc.
.Ve
.PP
Return the text styles as a chunk of \s-1CSS\s0 styling that can be embedded into
a \f(CW\*(C` style="" \*(C'\fR parameter.
.SS "\fIas_html()\fP"
.IX Subsection "as_html()"
.Vb 1
\&        my $html = $node\->as_html();
.Ve
.PP
Return the node as \s-1HTML\s0 code.
.SS "\fIattribute()\fP, \fIget_attribute()\fP"
.IX Subsection "attribute(), get_attribute()"
.Vb 1
\&        $node\->attribute(\*(Aqborder\-style\*(Aq);
.Ve
.PP
Returns the respective attribute of the node or undef if it
was not set. If there is a default attribute for all nodes
of the specific class the node is in, then this will be returned.
.SS "\fIget_attributes()\fP"
.IX Subsection "get_attributes()"
.Vb 1
\&        my $att = $object\->get_attributes();
.Ve
.PP
Return all effective attributes on this object (graph/node/group/edge) as
an anonymous hash ref. This respects inheritance and default values.
.PP
Note that this does not include custom attributes.
.PP
See also get_custom_attributes and \fIraw_attributes()\fR.
.SS "\fIget_custom_attributes()\fP"
.IX Subsection "get_custom_attributes()"
.Vb 1
\&        my $att = $object\->get_custom_attributes();
.Ve
.PP
Return all the custom attributes on this object (graph/node/group/edge) as
an anonymous hash ref.
.SS "\fIcustom_attributes()\fP"
.IX Subsection "custom_attributes()"
.Vb 1
\&    my $att = $object\->custom_attributes();
.Ve
.PP
\&\f(CW\*(C`custom_attributes()\*(C'\fR is an alias for get_custom_attributes.
.SS "\fIraw_attributes()\fP"
.IX Subsection "raw_attributes()"
.Vb 1
\&        my $att = $object\->get_attributes();
.Ve
.PP
Return all set attributes on this object (graph/node/group/edge) as
an anonymous hash ref. This respects inheritance, but does not include
default values for unset attributes.
.PP
See also \fIget_attributes()\fR.
.SS "\fIdefault_attribute()\fP"
.IX Subsection "default_attribute()"
.Vb 1
\&        my $def = $graph\->default_attribute($class, \*(Aqfill\*(Aq);
.Ve
.PP
Returns the default value for the given attribute \fBin the class\fR
of the object.
.PP
The default attribute is the value that will be used if
the attribute on the object itself, as well as the attribute
on the class is unset.
.PP
To find out what attribute is on the class, use the three-arg form
of attribute on the graph:
.PP
.Vb 2
\&        my $g = Graph::Easy\->new();
\&        my $node = $g\->add_node(\*(AqBerlin\*(Aq);
\&
\&        print $node\->attribute(\*(Aqfill\*(Aq), "\en";           # print "white"
\&        print $node\->default_attribute(\*(Aqfill\*(Aq), "\en";   # print "white"
\&        print $g\->attribute(\*(Aqnode\*(Aq,\*(Aqfill\*(Aq), "\en";       # print "white"
\&
\&        $g\->set_attribute(\*(Aqnode\*(Aq,\*(Aqfill\*(Aq,\*(Aqred\*(Aq);         # class is "red"
\&        $node\->set_attribute(\*(Aqfill\*(Aq,\*(Aqgreen\*(Aq);           # this object is "green"
\&
\&        print $node\->attribute(\*(Aqfill\*(Aq), "\en";           # print "green"
\&        print $node\->default_attribute(\*(Aqfill\*(Aq), "\en";   # print "white"
\&        print $g\->attribute(\*(Aqnode\*(Aq,\*(Aqfill\*(Aq), "\en";       # print "red"
.Ve
.PP
See also \fIraw_attribute()\fR.
.SS "attributes_as_txt"
.IX Subsection "attributes_as_txt"
.Vb 1
\&        my $txt = $node\->attributes_as_txt();
.Ve
.PP
Return the attributes of this node as text description. This is used
by the \f(CW\*(C`$graph\->as_txt()\*(C'\fR code and there should be no reason
to use this function on your own.
.SS "\fIset_attribute()\fP"
.IX Subsection "set_attribute()"
.Vb 1
\&        $node\->set_attribute(\*(Aqborder\-style\*(Aq, \*(Aqnone\*(Aq);
.Ve
.PP
Sets the specified attribute of this (and only this!) node to the
specified value.
.SS "\fIdel_attribute()\fP"
.IX Subsection "del_attribute()"
.Vb 1
\&        $node\->del_attribute(\*(Aqborder\-style\*(Aq);
.Ve
.PP
Deletes the specified attribute of this (and only this!) node.
.SS "\fIset_attributes()\fP"
.IX Subsection "set_attributes()"
.Vb 1
\&        $node\->set_attributes( $hash );
.Ve
.PP
Sets all attributes specified in \f(CW$hash\fR as key => value pairs in this
(and only this!) node.
.SS "\fIborder_attribute()\fP"
.IX Subsection "border_attribute()"
.Vb 1
\&        my $border = $node\->border_attribute();
.Ve
.PP
Assembles the \f(CW\*(C`border\-width\*(C'\fR, \f(CW\*(C`border\-color\*(C'\fR and \f(CW\*(C`border\-style\*(C'\fR attributes
into a string like \*(L"solid 1px red\*(R".
.SS "\fIcolor_attribute()\fP"
.IX Subsection "color_attribute()"
.Vb 2
\&        # returns f.i. #ff0000
\&        my $color = $node\->get_color_attribute( \*(Aqfill\*(Aq );
.Ve
.PP
Just like \fIget_attribute()\fR, but only for colors, and returns them as hex,
using the current colorscheme.
.SS "\fIget_color_attribute()\fP"
.IX Subsection "get_color_attribute()"
Is an alias for \fIcolor_attribute()\fR.
.SS "\fIraw_attribute()\fP, \fIget_raw_attribute()\fP"
.IX Subsection "raw_attribute(), get_raw_attribute()"
.Vb 1
\&        my $value = $object\->raw_attribute( $name );
.Ve
.PP
Return the value of attribute \f(CW$name\fR from the object it this
method is called on (graph, node, edge, group etc.). If the
attribute is not set on the object itself, returns undef.
.PP
This method respects inheritance, so an attribute value of 'inherit'
on an object will make the method return the inherited value:
.PP
.Vb 2
\&        my $g = Graph::Easy\->new();
\&        my $n = $g\->add_node(\*(AqA\*(Aq);
\&
\&        $g\->set_attribute(\*(Aqcolor\*(Aq,\*(Aqred\*(Aq);
\&
\&        print $n\->raw_attribute(\*(Aqcolor\*(Aq);               # undef
\&        $n\->set_attribute(\*(Aqcolor\*(Aq,\*(Aqinherit\*(Aq);
\&        print $n\->raw_attribute(\*(Aqcolor\*(Aq);               # \*(Aqred\*(Aq
.Ve
.PP
See also \fIattribute()\fR.
.SS "\fIraw_color_attribute()\fP"
.IX Subsection "raw_color_attribute()"
.Vb 2
\&        # returns f.i. #ff0000
\&        my $color = $graph\->raw_color_attribute(\*(Aqcolor\*(Aq );
.Ve
.PP
Just like \fIraw_attribute()\fR, but only for colors, and returns them as hex,
using the current colorscheme.
.PP
If the attribute is not set on the object, returns \f(CW\*(C`undef\*(C'\fR.
.SS "\fItext_styles()\fP"
.IX Subsection "text_styles()"
.Vb 5
\&        my $styles = $node\->text_styles();
\&        if ($styles\->{\*(Aqitalic\*(Aq})
\&          {
\&          print \*(Aqis italic\en\*(Aq;
\&          }
.Ve
.PP
Return a hash with the given text-style properties, aka 'underline', 'bold' etc.
.SS "\fIfind_grandparent()\fP"
.IX Subsection "find_grandparent()"
.Vb 1
\&        my $grandpa = $node\->find_grandparent();
.Ve
.PP
For a node that has no origin (is not relative to another), returns
\&\f(CW$node\fR. For all others, follows the chain of origin back until
a node without a parent is found and returns this node.
This code assumes there are no loops, which \f(CW\*(C`origin()\*(C'\fR prevents from
happening.
.SS "\fIname()\fP"
.IX Subsection "name()"
.Vb 1
\&        my $name = $node\->name();
.Ve
.PP
Return the name of the node. In a graph, each node has a unique name,
which, unless a node label is set, will be displayed when rendering the
graph.
.SS "\fIlabel()\fP"
.IX Subsection "label()"
.Vb 2
\&        my $label = $node\->label();
\&        my $label = $node\->label(1);            # raw
.Ve
.PP
Return the label of the node. If no label was set, returns the \f(CW\*(C`name\*(C'\fR
of the node.
.PP
If the optional parameter is true, then the label will returned 'raw',
that is any potential escape of the form \f(CW\*(C`\eN\*(C'\fR, \f(CW\*(C`\eE\*(C'\fR, \f(CW\*(C`\eG\*(C'\fR, \f(CW\*(C`\eT\*(C'\fR
or \f(CW\*(C`\eH\*(C'\fR will not be left alone and not be replaced.
.SS "\fIbackground()\fP"
.IX Subsection "background()"
.Vb 1
\&        my $bg = $node\->background();
.Ve
.PP
Returns the background color. This method honours group membership and
inheritance.
.SS "\fIquoted_comment()\fP"
.IX Subsection "quoted_comment()"
.Vb 1
\&        my $cmt = $node\->comment();
.Ve
.PP
Comment of this object, quoted suitable as to be embedded into \s-1HTML/SVG.\s0
Returns the empty string if this object doesn't have a comment set.
.SS "\fItitle()\fP"
.IX Subsection "title()"
.Vb 2
\&        my $title = $node\->title();
\&        my $title = $node\->title(1);            # raw
.Ve
.PP
Returns a potential title that can be used for mouse-over effects.
If no title was set (or autogenerated), will return an empty string.
.PP
If the optional parameter is true, then the title will returned 'raw',
that is any potential escape of the form \f(CW\*(C`\eN\*(C'\fR, \f(CW\*(C`\eE\*(C'\fR, \f(CW\*(C`\eG\*(C'\fR, \f(CW\*(C`\eT\*(C'\fR
or \f(CW\*(C`\eH\*(C'\fR will be left alone and not be replaced.
.SS "\fIlink()\fP"
.IX Subsection "link()"
.Vb 2
\&        my $link = $node\->link();
\&        my $link = $node\->link(1);              # raw
.Ve
.PP
Returns the \s-1URL,\s0 build from the \f(CW\*(C`linkbase\*(C'\fR and \f(CW\*(C`link\*(C'\fR (or \f(CW\*(C`autolink\*(C'\fR)
attributes.  If the node has no link associated with it, return an empty
string.
.PP
If the optional parameter is true, then the link will returned 'raw',
that is any potential escape of the form \f(CW\*(C`\eN\*(C'\fR, \f(CW\*(C`\eE\*(C'\fR, \f(CW\*(C`\eG\*(C'\fR, \f(CW\*(C`\eT\*(C'\fR
or \f(CW\*(C`\eH\*(C'\fR will not be left alone and not be replaced.
.SS "\fIdimensions()\fP"
.IX Subsection "dimensions()"
.Vb 1
\&        my ($w,$h) = $node\->dimensions();
.Ve
.PP
Returns the dimensions of the node/cell derived from the label (or name) in characters.
Assumes the label/name has literal '\en' replaced by \*(L"\en\*(R".
.SS "\fIsize()\fP"
.IX Subsection "size()"
.Vb 1
\&        my ($cx,$cy) = $node\->size();
.Ve
.PP
Returns the node size in cells.
.SS "\fIcontents()\fP"
.IX Subsection "contents()"
.Vb 1
\&        my $contents = $node\->contents();
.Ve
.PP
For nested nodes, returns the contents of the node.
.SS "\fIwidth()\fP"
.IX Subsection "width()"
.Vb 1
\&        my $width = $node\->width();
.Ve
.PP
Returns the width of the node. This is a unitless number.
.SS "\fIheight()\fP"
.IX Subsection "height()"
.Vb 1
\&        my $height = $node\->height();
.Ve
.PP
Returns the height of the node. This is a unitless number.
.SS "\fIcolumns()\fP"
.IX Subsection "columns()"
.Vb 1
\&        my $cols = $node\->columns();
.Ve
.PP
Returns the number of columns (in cells) that this node occupies.
.SS "\fIrows()\fP"
.IX Subsection "rows()"
.Vb 1
\&        my $cols = $node\->rows();
.Ve
.PP
Returns the number of rows (in cells) that this node occupies.
.SS "\fIis_multicelled()\fP"
.IX Subsection "is_multicelled()"
.Vb 4
\&        if ($node\->is_multicelled())
\&          {
\&          ...
\&          }
.Ve
.PP
Returns true if the node consists of more than one cell. See als
\&\fIrows()\fR and \fIcols()\fR.
.SS "\fIis_anon()\fP"
.IX Subsection "is_anon()"
.Vb 4
\&        if ($node\->is_anon())
\&          {
\&          ...
\&          }
.Ve
.PP
Returns true if the node is an anonymous node. False for \f(CW\*(C`Graph::Easy::Node\*(C'\fR
objects, and true for \f(CW\*(C`Graph::Easy::Node::Anon\*(C'\fR.
.SS "\fIpos()\fP"
.IX Subsection "pos()"
.Vb 1
\&        my ($x,$y) = $node\->pos();
.Ve
.PP
Returns the position of the node. Initially, this is undef, and will be
set from \fIGraph::Easy::layout()\fR. Only valid during the layout phase.
.SS "\fIoffset()\fP"
.IX Subsection "offset()"
.Vb 1
\&        my ($dx,$dy) = $node\->offset();
.Ve
.PP
Returns the position of the node relativ to the origin. Returns \f(CW\*(C`(0,0)\*(C'\fR if
the origin node was not sset.
.SS "x()"
.IX Subsection "x()"
.Vb 1
\&        my $x = $node\->x();
.Ve
.PP
Returns the X position of the node. Initially, this is undef, and will be
set from \fIGraph::Easy::layout()\fR. Only valid during the layout phase.
.SS "y()"
.IX Subsection "y()"
.Vb 1
\&        my $y = $node\->y();
.Ve
.PP
Returns the Y position of the node. Initially, this is undef, and will be
set from \fIGraph::Easy::layout()\fR. Only valid during the layout phase.
.SS "\fIid()\fP"
.IX Subsection "id()"
.Vb 1
\&        my $id = $node\->id();
.Ve
.PP
Returns the node's unique, internal \s-1ID\s0 number.
.SS "\fIconnections()\fP"
.IX Subsection "connections()"
.Vb 1
\&        my $cnt = $node\->connections();
.Ve
.PP
Returns the count of incoming and outgoing connections of this node.
Self-loops count as two connections, so in the following example, node \f(CW\*(C`N\*(C'\fR
has \fBfour\fR connections, but only \fBthree\fR edges:
.PP
.Vb 5
\&                    +\-\-+
\&                    v  |
\&        +\-\-\-+     +\-\-\-\-\-\-+     +\-\-\-+
\&        | 1 | \-\-> |  N   | \-\-> | 2 |
\&        +\-\-\-+     +\-\-\-\-\-\-+     +\-\-\-+
.Ve
.PP
See also \fIedges()\fR.
.SS "\fIedges()\fP"
.IX Subsection "edges()"
.Vb 1
\&        my $edges = $node\->edges();
.Ve
.PP
Returns a list of all the edges (as Graph::Easy::Edge objects) at this node,
in no particular order.
.SS "\fIpredecessors()\fP"
.IX Subsection "predecessors()"
.Vb 1
\&        my @pre = $node\->predecessors();
.Ve
.PP
Returns all nodes (as objects) that link to us.
.SS "\fIhas_predecessors()\fP"
.IX Subsection "has_predecessors()"
.Vb 4
\&        if ($node\->has_predecessors())
\&          {
\&          ...
\&          }
.Ve
.PP
Returns true if the node has one or more predecessors. Will return true for
nodes with selfloops.
.SS "\fIsuccessors()\fP"
.IX Subsection "successors()"
.Vb 1
\&        my @suc = $node\->successors();
.Ve
.PP
Returns all nodes (as objects) that we are linking to.
.SS "\fIsorted_successors()\fP"
.IX Subsection "sorted_successors()"
.Vb 1
\&        my @suc = $node\->sorted_successors();
.Ve
.PP
Return successors of the node sorted by their chain value
(e.g. successors with more successors first).
.SS "\fIhas_as_successor()\fP"
.IX Subsection "has_as_successor()"
.Vb 4
\&        if ($node\->has_as_successor($other))
\&          {
\&          ...
\&          }
.Ve
.PP
Returns true if \f(CW$other\fR ( a node or group) is a successor of node, that is if
there is an edge leading from node to \f(CW$other\fR.
.SS "\fIhas_as_predecessor()\fP"
.IX Subsection "has_as_predecessor()"
.Vb 4
\&        if ($node\->has_as_predecessor($other))
\&          {
\&          ...
\&          }
.Ve
.PP
Returns true if the node has \f(CW$other\fR (a group or node) as predecessor, that
is if there is an edge leading from \f(CW$other\fR to node.
.SS "\fIedges_to()\fP"
.IX Subsection "edges_to()"
.Vb 1
\&        my @edges = $node\->edges_to($other_node);
.Ve
.PP
Returns all the edges (as objects) that start at \f(CW$node\fR and go to
\&\f(CW$other_node\fR.
.SS "\fIshared_edges()\fP"
.IX Subsection "shared_edges()"
.Vb 1
\&        my @edges = $node\->shared_edges();
.Ve
.PP
Return a list of all edges starting/ending at this node, that share a port
with another edge.
.SS "\fInodes_sharing_start()\fP"
.IX Subsection "nodes_sharing_start()"
.Vb 1
\&        my @nodes = $node\->nodes_sharing_start($side, $port);
.Ve
.PP
Return a list of unique nodes that share a start point with an edge
from this node, on the specified side (absolute) and port number.
.SS "\fInodes_sharing_end()\fP"
.IX Subsection "nodes_sharing_end()"
.Vb 1
\&        my @nodes = $node\->nodes_sharing_end($side, $port);
.Ve
.PP
Return a list of unique nodes that share an end point with an edge
from this node, on the specified side (absolute) and port number.
.SS "\fIedges_at_port()\fP"
.IX Subsection "edges_at_port()"
.Vb 1
\&        my @edges = $node\->edges_to(\*(Aqstart\*(Aq, \*(Aqsouth\*(Aq, \*(Aq0\*(Aq);
.Ve
.PP
Returns all the edge objects that share the same \f(CW\*(C`start\*(C'\fR or \f(CW\*(C`end\*(C'\fR
port at the specified side and port number. The side must be
one of \f(CW\*(C`south\*(C'\fR, \f(CW\*(C`north\*(C'\fR, \f(CW\*(C`west\*(C'\fR or \f(CW\*(C`east\*(C'\fR. The port number
must be positive.
.SS "\fIincoming()\fP"
.IX Subsection "incoming()"
.Vb 1
\&        my @edges = $node\->incoming();
.Ve
.PP
Return all edges that end at this node.
.SS "\fIoutgoing()\fP"
.IX Subsection "outgoing()"
.Vb 1
\&        my @edges = $node\->outgoing();
.Ve
.PP
Return all edges that start at this node.
.SS "\fIadd_to_group()\fP"
.IX Subsection "add_to_group()"
.Vb 1
\&        $node\->add_to_group( $group );
.Ve
.PP
Put the node into this group.
.SS "\fIgroup()\fP"
.IX Subsection "group()"
.Vb 1
\&        my $group = $node\->group();
.Ve
.PP
Return the group this node belongs to, or undef.
.SS "\fIparent()\fP"
.IX Subsection "parent()"
.Vb 1
\&        my $parent = $node\->parent();
.Ve
.PP
Returns the parent object of the node, which is either the group the node belongs
to, or the graph.
.SS "\fIorigin()\fP"
.IX Subsection "origin()"
.Vb 1
\&        my $origin_node = $node\->origin();
.Ve
.PP
Returns the node this node is relativ to, or undef otherwise.
.SS "\fIrelative_to()\fP"
.IX Subsection "relative_to()"
.Vb 1
\&        $node\->relative_to($parent, $dx, $dy);
.Ve
.PP
Sets itself relativ to \f(CW$parent\fR with the offset \f(CW\*(C`$dx,$dy\*(C'\fR.
.SS "\fIshape()\fP"
.IX Subsection "shape()"
.Vb 1
\&        my $shape = $node\->shape();
.Ve
.PP
Returns the shape of the node as string, defaulting to 'rect'.
.SS "\fIangle()\fP"
.IX Subsection "angle()"
.Vb 1
\&        my $angle = $self\->rotation();
.Ve
.PP
Return the node's rotation, based on the \f(CW\*(C`rotate\*(C'\fR attribute, and
in case this is relative, on the node's flow.
.SS "\fIflow()\fP"
.IX Subsection "flow()"
.Vb 1
\&        my $flow = $node\->flow();
.Ve
.PP
Returns the outgoing flow for this node as absolute direction in degrees.
.PP
The value is computed from the incoming flow (or the general flow as
default) and the flow attribute of this node.
.SS "\fI_extra_params()\fP"
.IX Subsection "_extra_params()"
.Vb 1
\&        my $extra_params = $node\->_extra_params();
.Ve
.PP
The return value of that method is added as extra params to the
\&\s-1HTML\s0 tag for a node when \fIas_html()\fR is called. Returns the empty
string by default, and can be overridden in subclasses. See also
\&\fIuse_class()\fR.
.PP
Overridden method should return a text with a leading space, or the
empty string.
.PP
Example:
.PP
.Vb 2
\&        package Graph::Easy::MyNode;
\&        use base qw/Graph::Easy::Node/;
\&
\&        sub _extra_params
\&          {
\&          my $self = shift;
\&
\&          \*(Aq \*(Aq . \*(Aqonmouseover="alert(\e\*(Aq\*(Aq . $self\->name() . \*(Aq\e\*(Aq);"\*(Aq; 
\&          }
\&
\&        1;
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
None by default.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Graph::Easy.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 2004 \- 2007 by Tels <http://bloodgate.com>.
.PP
See the \s-1LICENSE\s0 file for more details.
