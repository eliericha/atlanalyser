.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Graph::Easy 3"
.TH Graph::Easy 3 "2014-04-12" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Graph::Easy \- Convert or render graphs (as ASCII, HTML, SVG or via Graphviz)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Graph::Easy;
\&        
\&        my $graph = Graph::Easy\->new();
\&
\&        # make a fresh copy of the graph
\&        my $new_graph = $graph\->copy();
\&
\&        $graph\->add_edge (\*(AqBonn\*(Aq, \*(AqBerlin\*(Aq);
\&
\&        # will not add it, since it already exists
\&        $graph\->add_edge_once (\*(AqBonn\*(Aq, \*(AqBerlin\*(Aq);
\&
\&        print $graph\->as_ascii( );              # prints:
\&
\&        # +\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-+
\&        # | Bonn | \-\-> | Berlin |
\&        # +\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-+
\&
\&        #####################################################
\&        # alternatively, let Graph::Easy parse some text:
\&
\&        my $graph = Graph::Easy\->new( \*(Aq[Bonn] \-> [Berlin]\*(Aq );
\&
\&        #####################################################
\&        # slightly more verbose way:
\&
\&        my $graph = Graph::Easy\->new();
\&
\&        my $bonn = $graph\->add_node(\*(AqBonn\*(Aq);
\&        $bonn\->set_attribute(\*(Aqborder\*(Aq, \*(Aqsolid 1px black\*(Aq);
\&
\&        my $berlin = $graph\->add_node(\*(AqBerlin\*(Aq);
\&
\&        $graph\->add_edge ($bonn, $berlin);
\&
\&        print $graph\->as_ascii( );
\&
\&        # You can use plain scalars as node names and for the edge label:
\&        $graph\->add_edge (\*(AqBerlin\*(Aq, \*(AqFrankfurt\*(Aq, \*(Aqvia train\*(Aq);
\&
\&        # adding edges with attributes:
\&
\&        my $edge = Graph::Easy::Edge\->new();
\&        $edge\->set_attributes( {
\&                label => \*(Aqtrain\*(Aq,
\&                style => \*(Aqdotted\*(Aq,
\&                color => \*(Aqred\*(Aq,
\&        } );
\&
\&        # now with the optional edge object
\&        $graph\->add_edge ($bonn, $berlin, $edge);
\&
\&        # raw HTML section
\&        print $graph\->as_html( );
\&
\&        # complete HTML page (with CSS)
\&        print $graph\->as_html_file( );
\&
\&        # Other possibilities:
\&
\&        # SVG (possible after you installed Graph::Easy::As_svg):
\&        print $graph\->as_svg( );
\&
\&        # Graphviz:
\&        my $graphviz = $graph\->as_graphviz();
\&        open $DOT, \*(Aq|dot \-Tpng \-o graph.png\*(Aq or die ("Cannot open pipe to dot: $!");
\&        print $DOT $graphviz;
\&        close $DOT;
\&
\&        # Please see also the command line utility \*(Aqgraph\-easy\*(Aq
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Graph::Easy\*(C'\fR lets you generate graphs consisting of various shaped
nodes connected by edges (with optional labels).
.PP
It can read and write graphs in a varity of formats, as well as render
them via its own grid-based layouter.
.PP
Since the layouter works on a grid (manhattan layout), the output is
most useful for flow charts, network diagrams, or hierarchy trees.
.PP

.IX Xref "graph drawing diagram flowchart layout manhattan"
.SS "Input"
.IX Subsection "Input"
Apart from driving the module with Perl code, you can also use
\&\f(CW\*(C`Graph::Easy::Parser\*(C'\fR to parse graph descriptions like:
.PP
.Vb 3
\&        [ Bonn ]      \-\-> [ Berlin ]
\&        [ Frankfurt ] <=> [ Dresden ]
\&        [ Bonn ]      \-\-  [ Frankfurt ]
.Ve
.PP
See the \f(CW\*(C`EXAMPLES\*(C'\fR section below for how this might be rendered.
.SS "Creating graphs"
.IX Subsection "Creating graphs"
First, create a graph object:
.PP
.Vb 1
\&        my $graph = Graph::Easy\->new();
.Ve
.PP
Then add a node to it:
.PP
.Vb 1
\&        my $node = $graph\->add_node(\*(AqKoblenz\*(Aq);
.Ve
.PP
Don't worry, adding the node again will do nothing:
.PP
.Vb 1
\&        $node = $graph\->add_node(\*(AqKoblenz\*(Aq);
.Ve
.PP
You can get back a node by its name with \f(CW\*(C`node()\*(C'\fR:
.PP
.Vb 1
\&        $node = $graph\->node(\*(AqKoblenz\*(Aq);
.Ve
.PP
You can either add another node:
.PP
.Vb 1
\&        my $second = $graph\->node(\*(AqFrankfurt\*(Aq);
.Ve
.PP
Or add an edge straight-away:
.PP
.Vb 1
\&        my ($first,$second,$edge) = $graph\->add_edge(\*(AqMainz\*(Aq,\*(AqUlm\*(Aq);
.Ve
.PP
Adding the edge the second time creates another edge from 'Mainz' to 'Ulm':
.PP
.Vb 2
\&        my $other_edge;
\&         ($first,$second,$other_edge) = $graph\->add_edge(\*(AqMainz\*(Aq,\*(AqUlm\*(Aq);
.Ve
.PP
This can be avoided by using \f(CW\*(C`add_edge_once()\*(C'\fR:
.PP
.Vb 6
\&        my $edge = $graph\->add_edge_once(\*(AqMainz\*(Aq,\*(AqUlm\*(Aq);
\&        if (defined $edge)
\&          {
\&          # the first time the edge was added, do something with it
\&          $edge\->set_attribute(\*(Aqcolor\*(Aq,\*(Aqblue\*(Aq);
\&          }
.Ve
.PP
You can set attributes on nodes and edges:
.PP
.Vb 2
\&        $node\->attribute(\*(Aqfill\*(Aq, \*(Aqyellow\*(Aq);
\&        $edge\->attribute(\*(Aqlabel\*(Aq, \*(Aqtrain\*(Aq);
.Ve
.PP
It is possible to add an edge with a label:
.PP
.Vb 1
\&        $graph\->add_edge(\*(AqCottbus\*(Aq, \*(AqBerlin\*(Aq, \*(Aqmy label\*(Aq);
.Ve
.PP
You can also add self-loops:
.PP
.Vb 1
\&        $graph\->add_edge(\*(AqBremen\*(Aq,\*(AqBremen\*(Aq);
.Ve
.PP
Adding multiple nodes is easy:
.PP
.Vb 1
\&        my ($bonn,$rom) = Graph::Easy\->add_nodes(\*(AqBonn\*(Aq,\*(AqRom\*(Aq);
.Ve
.PP
You can also have subgraphs (these are called groups):
.PP
.Vb 1
\&        my ($group) = Graph::Easy\->add_group(\*(AqCities\*(Aq);
.Ve
.PP
Only nodes can be part of a group, edges are automatically considered
to be in the group if they lead from one node inside the group to
another node in the same group. There are multiple ways to add one or
more nodes into a group:
.PP
.Vb 3
\&        $group\->add_member($bonn);
\&        $group\->add_node($rom);
\&        $group\->add_nodes($rom,$bonn);
.Ve
.PP
For more options please see the online manual: 
<http://bloodgate.com/perl/graph/manual/> .
.SS "Output"
.IX Subsection "Output"
The output can be done in various styles:
.IP "\s-1ASCII ART\s0" 2
.IX Item "ASCII ART"
Uses things like \f(CW\*(C`+\*(C'\fR, \f(CW\*(C`\-\*(C'\fR \f(CW\*(C`<\*(C'\fR and \f(CW\*(C`|\*(C'\fR to render the boxes.
.IP "\s-1BOXART\s0" 2
.IX Item "BOXART"
Uses Unicode box art drawing elements to output the graph.
.IP "\s-1HTML\s0" 2
.IX Item "HTML"
\&\s-1HTML\s0 tables with \s-1CSS\s0 making everything \*(L"pretty\*(R".
.IP "\s-1SVG\s0" 2
.IX Item "SVG"
Creates a Scalable Vector Graphics output.
.IP "Graphviz" 2
.IX Item "Graphviz"
Creates graphviz code that can be feed to 'dot', 'neato' or similar programs.
.IP "GraphML" 2
.IX Item "GraphML"
Creates a textual description of the graph in the GraphML format.
.IP "\s-1GDL/VCG\s0" 2
.IX Item "GDL/VCG"
Creates a textual description of the graph in the \s-1VCG\s0 or \s-1GDL \s0(Graph
Description Language) format.
.PP

.IX Xref "ascii html svg boxart graphviz dot neato"
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The following examples are given in the simple text format that is understood
by Graph::Easy::Parser.
.PP
You can also see many more examples at:
.PP
<http://bloodgate.com/perl/graph/>
.SS "One node"
.IX Subsection "One node"
The most simple graph (apart from the empty one :) is a graph consisting of
only one node:
.PP
.Vb 1
\&        [ Dresden ]
.Ve
.SS "Two nodes"
.IX Subsection "Two nodes"
A simple graph consisting of two nodes, linked together by a directed edge:
.PP
.Vb 1
\&        [ Bonn ] \-> [ Berlin ]
.Ve
.SS "Three nodes"
.IX Subsection "Three nodes"
A graph consisting of three nodes, and both are linked from the first:
.PP
.Vb 2
\&        [ Bonn ] \-> [ Berlin ]
\&        [ Bonn ] \-> [ Hamburg ]
.Ve
.SS "Three nodes in a chain"
.IX Subsection "Three nodes in a chain"
A graph consisting of three nodes, showing that you can chain connections together:
.PP
.Vb 1
\&        [ Bonn ] \-> [ Berlin ] \-> [ Hamburg ]
.Ve
.SS "Two not connected graphs"
.IX Subsection "Two not connected graphs"
A graph consisting of two separate parts, both of them not connected
to each other:
.PP
.Vb 2
\&        [ Bonn ] \-> [ Berlin ]
\&        [ Freiburg ] \-> [ Hamburg ]
.Ve
.SS "Three nodes, interlinked"
.IX Subsection "Three nodes, interlinked"
A graph consisting of three nodes, and two of the are connected from
the first node:
.PP
.Vb 3
\&        [ Bonn ] \-> [ Berlin ]
\&        [ Berlin ] \-> [ Hamburg ]
\&        [ Bonn ] \-> [ Hamburg ]
.Ve
.SS "Different edge styles"
.IX Subsection "Different edge styles"
A graph consisting of a couple of nodes, linked with the
different possible edge styles.
.PP
.Vb 8
\&        [ Bonn ] <\-> [ Berlin ]         # bidirectional
\&        [ Berlin ] ==> [ Rostock ]      # double
\&        [ Hamburg ] ..> [ Altona ]      # dotted
\&        [ Dresden ] \- > [ Bautzen ]     # dashed
\&        [ Leipzig ] ~~> [ Kirchhain ]   # wave
\&        [ Hof ] .\-> [ Chemnitz ]        # dot\-dash
\&        [ Magdeburg ] <=> [ Ulm ]       # bidrectional, double etc
\&        [ Magdeburg ] \-\- [ Ulm ]        # arrow\-less edge
.Ve
.PP
More examples at: <http://bloodgate.com/perl/graph/>
.SH "ANIMATION SUPPORT"
.IX Header "ANIMATION SUPPORT"
\&\fBNote: Animations are not yet implemented!\fR
.PP
It is possible to add animations to a graph. This is done by
adding \fIsteps\fR via the pseudo-class \f(CW\*(C`step\*(C'\fR:
.PP
.Vb 10
\&        step.0 {
\&          target: Bonn;         # find object with id=Bonn, or
\&                                # if this fails, the node named
\&                                # "Bonn".
\&          animate: fill:        # animate this attribute
\&          from: yellow;         # start value (0% of duration)
\&          via: red;             # at 50% of the duration
\&          to: yellow;           # and 100% of duration
\&          wait: 0;              # after triggering, wait so many seconds
\&          duration: 5;          # entire time to go from "from" to "to"
\&          trigger: onload;      # when to trigger this animation
\&          repeat: 2;            # how often to repeat ("2" means two times)
\&                                # also "infinite", then "next" will be ignored
\&          next: 1;              # which step to take after repeat is up
\&        }
\&        step.1 {
\&          from: white;          # set to white
\&          to: white;
\&          duration: 0.1;        # 100ms
\&          next: 0;              # go back to step.0
\&        }
.Ve
.PP
Here two steps are created, \fI0\fR and \fI1\fR and the animation will
be going like this:
.PP
.Vb 6
\&                               0.1s
\&                             +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&                             v                               |
\&        +\-\-\-\-\-\-\-\-+  0s   +\-\-\-\-\-\-\-\-+  5s   +\-\-\-\-\-\-\-\-+  5s   +\-\-\-\-\-\-\-\-+
\&        | onload | \-\-\-\-> | step.0 | \-\-\-\-> | step.0 | \-\-\-\-> | step.1 |
\&        +\-\-\-\-\-\-\-\-+       +\-\-\-\-\-\-\-\-+       +\-\-\-\-\-\-\-\-+       +\-\-\-\-\-\-\-\-+
.Ve
.PP
You can generate a a graph with the animation flow via
\&\f(CW\*(C`animation_as_graph()\*(C'\fR.
.SS "Output"
.IX Subsection "Output"
Currently no output formats supports animations yet.
.SH "METHODS"
.IX Header "METHODS"
\&\f(CW\*(C`Graph::Easy\*(C'\fR supports the following methods:
.SS "\fInew()\fP"
.IX Subsection "new()"
.Vb 1
\&        use Graph::Easy;
\&
\&        my $graph = Graph::Easy\->new( );
.Ve
.PP
Creates a new, empty \f(CW\*(C`Graph::Easy\*(C'\fR object.
.PP
Takes optinal a hash reference with a list of options. The following are
valid options:
.PP
.Vb 5
\&        debug                   if true, enables debug output
\&        timeout                 timeout (in seconds) for the layouter
\&        fatal_errors            wrong attributes are fatal errors, default: true
\&        strict                  test attribute names for being valid, default: true
\&        undirected              create an undirected graph, default: false
.Ve
.SS "\fIcopy()\fP"
.IX Subsection "copy()"
.Vb 1
\&    my $copy = $graph\->copy( );
.Ve
.PP
Create a copy of this graph and return it as a new Graph::Easy object.
.SS "\fIerror()\fP"
.IX Subsection "error()"
.Vb 1
\&        my $error = $graph\->error();
.Ve
.PP
Returns the last error or '' for none.
Optionally, takes an error message to be set.
.PP
.Vb 1
\&        $graph\->error( \*(AqExpected Foo, but found Bar.\*(Aq );
.Ve
.PP
See \fIwarn()\fR on how to catch error messages. See also \fInon_fatal_errors()\fR
on how to turn errors into warnings.
.SS "\fIwarn()\fP"
.IX Subsection "warn()"
.Vb 1
\&        my $warning = $graph\->warn();
.Ve
.PP
Returns the last warning or '' for none.
Optionally, takes a warning message to be output to \s-1STDERR:\s0
.PP
.Vb 1
\&        $graph\->warn( \*(AqExpected Foo, but found Bar.\*(Aq );
.Ve
.PP
If you want to catch warnings from the layouter, enable catching
of warnings or errors:
.PP
.Vb 1
\&        $graph\->catch_messages(1);
\&
\&        # Or individually:
\&        # $graph\->catch_warnings(1);
\&        # $graph\->catch_errors(1);
\&
\&        # something which warns or throws an error:
\&        ...
\&
\&        if ($graph\->error())
\&          {
\&          my @errors = $graph\->errors();
\&          }
\&        if ($graph\->warning())
\&          {
\&          my @warnings = $graph\->warnings();
\&          }
.Ve
.PP
See Graph::Easy::Base for more details on error/warning message capture.
.SS "\fIadd_edge()\fP"
.IX Subsection "add_edge()"
.Vb 1
\&        my ($first, $second, $edge) = $graph\->add_edge( \*(Aqnode 1\*(Aq, \*(Aqnode 2\*(Aq);
.Ve
.SS "\fIadd_edge()\fP"
.IX Subsection "add_edge()"
.Vb 3
\&        my ($first, $second, $edge) = $graph\->add_edge( \*(Aqnode 1\*(Aq, \*(Aqnode 2\*(Aq);
\&        my $edge = $graph\->add_edge( $x, $y, $edge);
\&        $graph\->add_edge( $x, $y);
.Ve
.PP
Add an edge between nodes X and Y. The optional edge object defines
the style of the edge, if not present, a default object will be used.
.PP
When called in scalar context, will return \f(CW$edge\fR. In array/list context
it will return the two nodes and the edge object.
.PP
\&\f(CW$x\fR and \f(CW$y\fR should be either plain scalars with the names of
the nodes, or objects of Graph::Easy::Node,
while the optional \f(CW$edge\fR should be Graph::Easy::Edge.
.PP
Note: \f(CW\*(C`Graph::Easy\*(C'\fR graphs are multi-edged, and adding the same edge
twice will result in two edges going from \f(CW$x\fR to \f(CW$y\fR! See
\&\f(CW\*(C`add_edge_once()\*(C'\fR on how to avoid that.
.PP
You can also use \f(CW\*(C`edge()\*(C'\fR to check whether an edge from X to Y already exists
in the graph.
.SS "\fIadd_edge_once()\fP"
.IX Subsection "add_edge_once()"
.Vb 3
\&        my ($first, $second, $edge) = $graph\->add_edge_once( \*(Aqnode 1\*(Aq, \*(Aqnode 2\*(Aq);
\&        my $edge = $graph\->add_edge_once( $x, $y, $edge);
\&        $graph\->add_edge_once( $x, $y);
\&
\&        if (defined $edge)
\&          {
\&          # got added once, so do something with it
\&          $edge\->set_attribute(\*(Aqlabel\*(Aq,\*(Aqunique\*(Aq);
\&          }
.Ve
.PP
Adds an edge between nodes X and Y, unless there exists already
an edge between these two nodes. See \f(CW\*(C`add_edge()\*(C'\fR.
.PP
Returns undef when an edge between X and Y already exists.
.PP
When called in scalar context, will return \f(CW$edge\fR. In array/list context
it will return the two nodes and the edge object.
.SS "\fIflip_edges()\fP"
.IX Subsection "flip_edges()"
.Vb 3
\&        my $graph = Graph::Easy\->new();
\&        $graph\->add_edge(\*(AqBonn\*(Aq,\*(AqBerlin\*(Aq);
\&        $graph\->add_edge(\*(AqBerlin\*(Aq,\*(AqBonn\*(Aq);
\&
\&        print $graph\->as_ascii();
\&
\&        #   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&        #   v              |
\&        # +\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-+
\&        # | Berlin | \-\-> | Bonn |
\&        # +\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-+
\&
\&        $graph\->flip_edges(\*(AqBonn\*(Aq, \*(AqBerlin\*(Aq);
\&
\&        print $graph\->as_ascii();
\&
\&        #   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&        #   |              v
\&        # +\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-+
\&        # | Berlin | \-\-> | Bonn |
\&        # +\-\-\-\-\-\-\-\-+     +\-\-\-\-\-\-+
.Ve
.PP
Turn around (transpose) all edges that are going from the first node to the
second node.
.PP

.IX Xref "transpose"
.SS "\fIadd_node()\fP"
.IX Subsection "add_node()"
.Vb 3
\&        my $node = $graph\->add_node( \*(AqNode 1\*(Aq );
\&        # or if you already have a Graph::Easy::Node object:
\&        $graph\->add_node( $x );
.Ve
.PP
Add a single node X to the graph. \f(CW$x\fR should be either a
\&\f(CW\*(C`Graph::Easy::Node\*(C'\fR object, or a unique name for the node. Will do
nothing if the node already exists in the graph.
.PP
It returns an Graph::Easy::Node object.
.SS "\fIadd_anon_node()\fP"
.IX Subsection "add_anon_node()"
.Vb 1
\&        my $anon_node = $graph\->add_anon_node( );
.Ve
.PP
Creates a single, anonymous node and adds it to the graph, returning the
\&\f(CW\*(C`Graph::Easy::Node::Anon\*(C'\fR object.
.PP
The created node is equal to one created via \f(CW\*(C` [ ] \*(C'\fR in the Graph::Easy
text description.
.SS "\fIadd_nodes()\fP"
.IX Subsection "add_nodes()"
.Vb 1
\&        my @nodes = $graph\->add_nodes( \*(AqNode 1\*(Aq, \*(AqNode 2\*(Aq );
.Ve
.PP
Add all the given nodes to the graph. The arguments should be either a
\&\f(CW\*(C`Graph::Easy::Node\*(C'\fR object, or a unique name for the node. Will do
nothing if the node already exists in the graph.
.PP
It returns a list of Graph::Easy::Node objects.
.SS "\fIrename_node()\fP"
.IX Subsection "rename_node()"
.Vb 1
\&        $node = $graph\->rename_node($node, $new_name);
.Ve
.PP
Changes the name of a node. If the passed node is not part of
this graph or just a string, it will be added with the new
name to this graph.
.PP
If the node was part of another graph, it will be deleted there and added
to this graph with the new name, effectively moving the node from the old
to the new graph and renaming it at the same time.
.SS "\fIdel_node()\fP"
.IX Subsection "del_node()"
.Vb 2
\&        $graph\->del_node(\*(AqNode name\*(Aq);
\&        $graph\->del_node($node);
.Ve
.PP
Delete the node with the given name from the graph.
.SS "\fIdel_edge()\fP"
.IX Subsection "del_edge()"
.Vb 1
\&        $graph\->del_edge($edge);
.Ve
.PP
Delete the given edge object from the graph. You can use \f(CW\*(C`edge()\*(C'\fR to find
an edge from Node A to B:
.PP
.Vb 1
\&        $graph\->del_edge( $graph\->edge(\*(AqA\*(Aq,\*(AqB\*(Aq) );
.Ve
.SS "\fImerge_nodes()\fP"
.IX Subsection "merge_nodes()"
.Vb 2
\&        $graph\->merge_nodes( $first_node, $second_node );
\&        $graph\->merge_nodes( $first_node, $second_node, $joiner );
.Ve
.PP
Merge two nodes. Will delete all connections between the two nodes, then
move over any connection to/from the second node to the first, then delete
the second node from the graph.
.PP
Any attributes on the second node will be lost.
.PP
If present, the optional \f(CW$joiner\fR argument will be used to join
the label of the second node to the label of the first node. If not
present, the label of the second node will be dropped along with all
the other attributes:
.PP
.Vb 1
\&        my $graph = Graph::Easy\->new(\*(Aq[A]\->[B]\->[C]\->[D]\*(Aq);
\&
\&        # this produces "[A]\->[C]\->[D]"
\&        $graph\->merge_nodes( \*(AqA\*(Aq, \*(AqB\*(Aq );
\&
\&        # this produces "[A C]\->[D]"
\&        $graph\->merge_nodes( \*(AqA\*(Aq, \*(AqC\*(Aq, \*(Aq \*(Aq );
\&
\&        # this produces "[A C \en D]", note single quotes on the third argument!
\&        $graph\->merge_nodes( \*(AqA\*(Aq, \*(AqC\*(Aq, \*(Aq \en \*(Aq );
.Ve
.SS "\fIget_attribute()\fP"
.IX Subsection "get_attribute()"
.Vb 1
\&        my $value = $graph\->get_attribute( $class, $name );
.Ve
.PP
Return the value of attribute \f(CW$name\fR from class \f(CW$class\fR.
.PP
Example:
.PP
.Vb 1
\&        my $color = $graph\->attribute( \*(Aqnode\*(Aq, \*(Aqcolor\*(Aq );
.Ve
.PP
You can also call all the various attribute related methods on members of the
graph directly, for instance:
.PP
.Vb 3
\&        $node\->get_attribute(\*(Aqlabel\*(Aq);
\&        $edge\->get_attribute(\*(Aqcolor\*(Aq);
\&        $group\->get_attribute(\*(Aqfill\*(Aq);
.Ve
.SS "\fIattribute()\fP"
.IX Subsection "attribute()"
.Vb 1
\&        my $value = $graph\->attribute( $class, $name );
.Ve
.PP
Is an alias for get_attribute.
.SS "\fIcolor_attribute()\fP"
.IX Subsection "color_attribute()"
.Vb 2
\&        # returns f.i. #ff0000
\&        my $color = $graph\->get_color_attribute( \*(Aqnode\*(Aq, \*(Aqcolor\*(Aq );
.Ve
.PP
Just like \fIget_attribute()\fR, but only for colors, and returns them as hex,
using the current colorscheme.
.SS "\fIget_color_attribute()\fP"
.IX Subsection "get_color_attribute()"
Is an alias for \fIcolor_attribute()\fR.
.SS "\fIget_attributes()\fP"
.IX Subsection "get_attributes()"
.Vb 1
\&        my $att = $object\->get_attributes();
.Ve
.PP
Return all effective attributes on this object (graph/node/group/edge) as
an anonymous hash ref. This respects inheritance and default values.
.PP
Note that this does not include custom attributes.
.PP
See also get_custom_attributes and \fIraw_attributes()\fR.
.SS "\fIget_custom_attributes()\fP"
.IX Subsection "get_custom_attributes()"
.Vb 1
\&        my $att = $object\->get_custom_attributes();
.Ve
.PP
Return all the custom attributes on this object (graph/node/group/edge) as
an anonymous hash ref.
.SS "\fIcustom_attributes()\fP"
.IX Subsection "custom_attributes()"
.Vb 1
\&        my $att = $object\->custom_attributes();
.Ve
.PP
\&\f(CW\*(C`custom_attributes()\*(C'\fR is an alias for get_custom_attributes.
.SS "\fIraw_attributes()\fP"
.IX Subsection "raw_attributes()"
.Vb 1
\&        my $att = $object\->raw_attributes();
.Ve
.PP
Return all set attributes on this object (graph, node, group or edge) as
an anonymous hash ref. Thus you get all the locally active attributes
for this object.
.PP
Inheritance is respected, e.g. attributes that have the value \*(L"inherit\*(R"
and are inheritable, will be inherited from the base class.
.PP
But default values for unset attributes are skipped. Here is an example:
.PP
.Vb 1
\&        node { color: red; }
\&
\&        [ A ] { class: foo; color: inherit; }
.Ve
.PP
This will return:
.PP
.Vb 1
\&        { class => foo, color => red }
.Ve
.PP
As you can see, attributes like \f(CW\*(C`background\*(C'\fR etc. are not included, while
the color value was inherited properly.
.PP
See also \fIget_attributes()\fR.
.SS "\fIdefault_attribute()\fP"
.IX Subsection "default_attribute()"
.Vb 1
\&        my $def = $graph\->default_attribute($class, \*(Aqfill\*(Aq);
.Ve
.PP
Returns the default value for the given attribute \fBin the class\fR
of the object.
.PP
The default attribute is the value that will be used if
the attribute on the object itself, as well as the attribute
on the class is unset.
.PP
To find out what attribute is on the class, use the three-arg form
of attribute on the graph:
.PP
.Vb 2
\&        my $g = Graph::Easy\->new();
\&        my $node = $g\->add_node(\*(AqBerlin\*(Aq);
\&
\&        print $node\->attribute(\*(Aqfill\*(Aq), "\en";           # print "white"
\&        print $node\->default_attribute(\*(Aqfill\*(Aq), "\en";   # print "white"
\&        print $g\->attribute(\*(Aqnode\*(Aq,\*(Aqfill\*(Aq), "\en";       # print "white"
\&
\&        $g\->set_attribute(\*(Aqnode\*(Aq,\*(Aqfill\*(Aq,\*(Aqred\*(Aq);         # class is "red"
\&        $node\->set_attribute(\*(Aqfill\*(Aq,\*(Aqgreen\*(Aq);           # this object is "green"
\&
\&        print $node\->attribute(\*(Aqfill\*(Aq), "\en";           # print "green"
\&        print $node\->default_attribute(\*(Aqfill\*(Aq), "\en";   # print "white"
\&        print $g\->attribute(\*(Aqnode\*(Aq,\*(Aqfill\*(Aq), "\en";       # print "red"
.Ve
.PP
See also \fIraw_attribute()\fR.
.SS "\fIraw_attribute()\fP"
.IX Subsection "raw_attribute()"
.Vb 1
\&        my $value = $object\->raw_attribute( $name );
.Ve
.PP
Return the value of attribute \f(CW$name\fR from the object it this
method is called on (graph, node, edge, group etc.). If the
attribute is not set on the object itself, returns undef.
.PP
This method respects inheritance, so an attribute value of 'inherit'
on an object will make the method return the inherited value:
.PP
.Vb 2
\&        my $g = Graph::Easy\->new();
\&        my $n = $g\->add_node(\*(AqA\*(Aq);
\&
\&        $g\->set_attribute(\*(Aqcolor\*(Aq,\*(Aqred\*(Aq);
\&
\&        print $n\->raw_attribute(\*(Aqcolor\*(Aq);               # undef
\&        $n\->set_attribute(\*(Aqcolor\*(Aq,\*(Aqinherit\*(Aq);
\&        print $n\->raw_attribute(\*(Aqcolor\*(Aq);               # \*(Aqred\*(Aq
.Ve
.PP
See also \fIattribute()\fR.
.SS "\fIraw_color_attribute()\fP"
.IX Subsection "raw_color_attribute()"
.Vb 2
\&        # returns f.i. #ff0000
\&        my $color = $graph\->raw_color_attribute(\*(Aqcolor\*(Aq );
.Ve
.PP
Just like \fIraw_attribute()\fR, but only for colors, and returns them as hex,
using the current colorscheme.
.PP
If the attribute is not set on the object, returns \f(CW\*(C`undef\*(C'\fR.
.SS "\fIraw_attributes()\fP"
.IX Subsection "raw_attributes()"
.Vb 1
\&        my $att = $object\->raw_attributes();
.Ve
.PP
Returns a hash with all the raw attributes of that object.
Attributes that are no set on the object itself, but on
the class this object belongs to are \fBnot\fR included.
.PP
This method respects inheritance, so an attribute value of 'inherit'
on an object will make the method return the inherited value.
.SS "\fIset_attribute()\fP"
.IX Subsection "set_attribute()"
.Vb 2
\&        # Set the attribute on the given class.
\&        $graph\->set_attribute( $class, $name, $val );
\&
\&        # Set the attribute on the graph itself. This is synonymous
\&        # to using \*(Aqgraph\*(Aq as class in the form above.
\&        $graph\->set_attribute( $name, $val );
.Ve
.PP
Sets a given attribute named \f(CW$name\fR to the new value \f(CW$val\fR in the class
specified in \f(CW$class\fR.
.PP
Example:
.PP
.Vb 1
\&        $graph\->set_attribute( \*(Aqgraph\*(Aq, \*(Aqgid\*(Aq, \*(Aq123\*(Aq );
.Ve
.PP
The class can be one of \f(CW\*(C`graph\*(C'\fR, \f(CW\*(C`edge\*(C'\fR, \f(CW\*(C`node\*(C'\fR or \f(CW\*(C`group\*(C'\fR. The last
three can also have subclasses like in \f(CW\*(C`node.subclassname\*(C'\fR.
.PP
You can also call the various attribute related methods on members of the
graph directly, for instance:
.PP
.Vb 3
\&        $node\->set_attribute(\*(Aqlabel\*(Aq, \*(Aqmy node\*(Aq);
\&        $edge\->set_attribute(\*(Aqcolor\*(Aq, \*(Aqred\*(Aq);
\&        $group\->set_attribute(\*(Aqfill\*(Aq, \*(Aqgreen\*(Aq);
.Ve
.SS "\fIset_attributes()\fP"
.IX Subsection "set_attributes()"
.Vb 1
\&        $graph\->set_attributes( $class, $att );
.Ve
.PP
Given a class name in \f(CW$class\fR and a hash of mappings between attribute names
and values in \f(CW$att\fR, will set all these attributes.
.PP
The class can be one of \f(CW\*(C`graph\*(C'\fR, \f(CW\*(C`edge\*(C'\fR, \f(CW\*(C`node\*(C'\fR or \f(CW\*(C`group\*(C'\fR. The last
three can also have subclasses like in \f(CW\*(C`node.subclassname\*(C'\fR.
.PP
Example:
.PP
.Vb 1
\&        $graph\->set_attributes( \*(Aqnode\*(Aq, { color => \*(Aqred\*(Aq, background => \*(Aqnone\*(Aq } );
.Ve
.SS "\fIdel_attribute()\fP"
.IX Subsection "del_attribute()"
.Vb 1
\&        $graph\->del_attribute(\*(Aqborder\*(Aq);
.Ve
.PP
Delete the attribute with the given name from the object.
.PP
You can also call the various attribute related methods on members of the
graph directly, for instance:
.PP
.Vb 3
\&        $node\->del_attribute(\*(Aqlabel\*(Aq);
\&        $edge\->del_attribute(\*(Aqcolor\*(Aq);
\&        $group\->del_attribute(\*(Aqfill\*(Aq);
.Ve
.SS "\fIunquote_attribute()\fP"
.IX Subsection "unquote_attribute()"
.Vb 4
\&        # returns \*(Aq"Hello World!"\*(Aq
\&        my $value = $self\->unquote_attribute(\*(Aqnode\*(Aq,\*(Aqlabel\*(Aq,\*(Aq"Hello World!"\*(Aq);
\&        # returns \*(Aqred\*(Aq
\&        my $color = $self\->unquote_attribute(\*(Aqnode\*(Aq,\*(Aqcolor\*(Aq,\*(Aq"red"\*(Aq);
.Ve
.PP
Return the attribute unquoted except for labels and titles, that is it removes
double quotes at the start and the end of the string, unless these are
escaped with a backslash.
.SS "\fIborder_attribute()\fP"
.IX Subsection "border_attribute()"
.Vb 1
\&        my $border = $graph\->border_attribute();
.Ve
.PP
Return the combined border attribute like \*(L"1px solid red\*(R" from the
border(style|color|width) attributes.
.SS "\fIsplit_border_attributes()\fP"
.IX Subsection "split_border_attributes()"
.Vb 1
\&        my ($style,$width,$color) = $graph\->split_border_attribute($border);
.Ve
.PP
Split the border attribute (like \*(L"1px solid red\*(R") into the three different parts.
.SS "\fIquoted_comment()\fP"
.IX Subsection "quoted_comment()"
.Vb 1
\&        my $cmt = $node\->comment();
.Ve
.PP
Comment of this object, quoted suitable as to be embedded into \s-1HTML/SVG.\s0
Returns the empty string if this object doesn't have a comment set.
.SS "\fIflow()\fP"
.IX Subsection "flow()"
.Vb 1
\&        my $flow = $graph\->flow();
.Ve
.PP
Returns the flow of the graph, as absolute number in degress.
.SS "\fIsource_nodes()\fP"
.IX Subsection "source_nodes()"
.Vb 1
\&        my @roots = $graph\->source_nodes();
.Ve
.PP
Returns all nodes that have only outgoing edges, e.g. are the root of a tree,
in no particular order.
.PP
Isolated nodes (no edges at all) will \fBnot\fR be included, see
\&\fIpredecessorless_nodes()\fR to get these, too.
.PP
In scalar context, returns the number of source nodes.
.SS "\fIpredecessorless_nodes()\fP"
.IX Subsection "predecessorless_nodes()"
.Vb 1
\&        my @roots = $graph\->predecessorless_nodes();
.Ve
.PP
Returns all nodes that have no incoming edges, regardless of whether
they have outgoing edges or not, in no particular order.
.PP
Isolated nodes (no edges at all) \fBwill\fR be included in the list.
.PP
See also \fIsource_nodes()\fR.
.PP
In scalar context, returns the number of predecessorless nodes.
.SS "\fIroot_node()\fP"
.IX Subsection "root_node()"
.Vb 1
\&        my $root = $graph\->root_node();
.Ve
.PP
Return the root node as Graph::Easy::Node object, if it was
set with the 'root' attribute.
.SS "\fItimeout()\fP"
.IX Subsection "timeout()"
.Vb 2
\&        print $graph\->timeout(), " seconds timeout for layouts.\en";
\&        $graph\->timeout(12);
.Ve
.PP
Get/set the timeout for layouts in seconds. If the layout process did not
finish after that time, it will be stopped and a warning will be printed.
.PP
The default timeout is 5 seconds.
.SS "\fIstrict()\fP"
.IX Subsection "strict()"
.Vb 2
\&        print "Graph has strict checking\en" if $graph\->strict();
\&        $graph\->strict(undef);          # disable strict attribute checks
.Ve
.PP
Get/set the strict option. When set to a true value, all attribute names and
values will be strictly checked and unknown/invalid one will be rejected.
.PP
This option is on by default.
.SS "\fItype()\fP"
.IX Subsection "type()"
.Vb 1
\&        print "Graph is " . $graph\->type() . "\en";
.Ve
.PP
Returns the type of the graph as string, either \*(L"directed\*(R" or \*(L"undirected\*(R".
.SS "\fIlayout()\fP"
.IX Subsection "layout()"
.Vb 2
\&        $graph\->layout();
\&        $graph\->layout( type => \*(Aqforce\*(Aq, timeout => 60 );
.Ve
.PP
Creates the internal structures to layout the graph.
.PP
This method will be called automatically when you call any of the
\&\f(CW\*(C`as_FOO\*(C'\fR methods or \f(CW\*(C`output()\*(C'\fR as described below.
.PP
The options are:
.PP
.Vb 4
\&        type            the type of the layout, possible values:
\&                        \*(Aqforce\*(Aq         \- force based layouter
\&                        \*(Aqadhoc\*(Aq         \- the default layouter
\&        timeout         timeout in seconds
.Ve
.PP
See also: \fItimeout()\fR.
.SS "\fIoutput_format()\fP"
.IX Subsection "output_format()"
.Vb 1
\&        $graph\->output_format(\*(Aqhtml\*(Aq);
.Ve
.PP
Set the outputformat. One of 'html', 'ascii', 'graphviz', 'svg' or 'txt'.
See also \fIoutput()\fR.
.SS "\fIoutput()\fP"
.IX Subsection "output()"
.Vb 1
\&        my $out = $graph\->output();
.Ve
.PP
Output the graph in the format set by \f(CW\*(C`output_format()\*(C'\fR.
.SS "\fIas_ascii()\fP"
.IX Subsection "as_ascii()"
.Vb 1
\&        print $graph\->as_ascii();
.Ve
.PP
Return the graph layout in \s-1ASCII\s0 art, in utf\-8.
.SS "\fIas_ascii_file()\fP"
.IX Subsection "as_ascii_file()"
.Vb 1
\&        print $graph\->as_ascii_file();
.Ve
.PP
Is an alias for as_ascii.
.SS "\fIas_ascii_html()\fP"
.IX Subsection "as_ascii_html()"
.Vb 1
\&        print $graph\->as_ascii_html();
.Ve
.PP
Return the graph layout in \s-1ASCII\s0 art, suitable to be embedded into an \s-1HTML\s0
page. Basically it wraps the output from \fIas_ascii()\fR into
\&\f(CW\*(C`<pre> </pre>\*(C'\fR and inserts real \s-1HTML\s0 links. The returned
string is in utf\-8.
.SS "\fIas_boxart()\fP"
.IX Subsection "as_boxart()"
.Vb 1
\&        print $graph\->as_box();
.Ve
.PP
Return the graph layout as box drawing using Unicode characters (in utf\-8,
as always).
.SS "\fIas_boxart_file()\fP"
.IX Subsection "as_boxart_file()"
.Vb 1
\&        print $graph\->as_boxart_file();
.Ve
.PP
Is an alias for \f(CW\*(C`as_box\*(C'\fR.
.SS "\fIas_boxart_html()\fP"
.IX Subsection "as_boxart_html()"
.Vb 1
\&        print $graph\->as_boxart_html();
.Ve
.PP
Return the graph layout as box drawing using Unicode characters,
as chunk that can be embedded into an \s-1HTML\s0 page.
.PP
Basically it wraps the output from \fIas_boxart()\fR into
\&\f(CW\*(C`<pre> </pre>\*(C'\fR and inserts real \s-1HTML\s0 links. The returned
string is in utf\-8.
.SS "\fIas_boxart_html_file()\fP"
.IX Subsection "as_boxart_html_file()"
.Vb 1
\&        print $graph\->as_boxart_html_file();
.Ve
.PP
Return the graph layout as box drawing using Unicode characters,
as a full \s-1HTML\s0 page complete with header and footer.
.SS "\fIas_html()\fP"
.IX Subsection "as_html()"
.Vb 1
\&        print $graph\->as_html();
.Ve
.PP
Return the graph layout as \s-1HTML\s0 section. See \fIcss()\fR to get the
\&\s-1CSS\s0 section to go with that \s-1HTML\s0 code. If you want a complete \s-1HTML\s0 page
then use \fIas_html_file()\fR.
.SS "\fIas_html_page()\fP"
.IX Subsection "as_html_page()"
.Vb 1
\&        print $graph\->as_html_page();
.Ve
.PP
Is an alias for \f(CW\*(C`as_html_file\*(C'\fR.
.SS "\fIas_html_file()\fP"
.IX Subsection "as_html_file()"
.Vb 1
\&        print $graph\->as_html_file();
.Ve
.PP
Return the graph layout as \s-1HTML\s0 complete with headers, \s-1CSS\s0 section and
footer. Can be viewed in the browser of your choice.
.SS "\fIadd_group()\fP"
.IX Subsection "add_group()"
.Vb 1
\&        my $group = $graph\->add_group(\*(AqGroup name\*(Aq);
.Ve
.PP
Add a group to the graph and return it as Graph::Easy::Group object.
.SS "\fIgroup()\fP"
.IX Subsection "group()"
.Vb 1
\&        my $group = $graph\->group(\*(AqName\*(Aq);
.Ve
.PP
Returns the group with the name \f(CW\*(C`Name\*(C'\fR as Graph::Easy::Group object.
.SS "\fIrename_group()\fP"
.IX Subsection "rename_group()"
.Vb 1
\&        $group = $graph\->rename_group($group, $new_name);
.Ve
.PP
Changes the name of the given group. If the passed group is not part of
this graph or just a string, it will be added with the new
name to this graph.
.PP
If the group was part of another graph, it will be deleted there and added
to this graph with the new name, effectively moving the group from the old
to the new graph and renaming it at the same time.
.SS "\fIgroups()\fP"
.IX Subsection "groups()"
.Vb 1
\&        my @groups = $graph\->groups();
.Ve
.PP
Returns the groups of the graph as Graph::Easy::Group objects,
in arbitrary order.
.SS "\fIgroups_within()\fP"
.IX Subsection "groups_within()"
.Vb 3
\&        # equivalent to $graph\->groups():
\&        my @groups = $graph\->groups_within();           # all
\&        my @toplevel_groups = $graph\->groups_within(0); # level 0 only
.Ve
.PP
Return the groups that are inside this graph, up to the specified level,
in arbitrary order.
.PP
The default level is \-1, indicating no bounds and thus all contained
groups are returned.
.PP
A level of 0 means only the direct children, and hence only the toplevel
groups will be returned. A level 1 means the toplevel groups and their
toplevel children, and so on.
.SS "\fIanon_groups()\fP"
.IX Subsection "anon_groups()"
.Vb 1
\&        my $anon_groups = $graph\->anon_groups();
.Ve
.PP
In scalar context, returns the number of anon groups (aka
Graph::Easy::Group::Anon) the graph has.
.PP
In list context, returns all anon groups as objects, in arbitrary order.
.SS "\fIdel_group()\fP"
.IX Subsection "del_group()"
.Vb 1
\&        $graph\->del_group($name);
.Ve
.PP
Delete the group with the given name.
.SS "\fIedges()\fP, \fIedges_within()\fP"
.IX Subsection "edges(), edges_within()"
.Vb 1
\&        my @edges = $graph\->edges();
.Ve
.PP
Returns the edges of the graph as Graph::Easy::Edge objects,
in arbitrary order.
.PP
\&\fIedges_within()\fR is an alias for \f(CW\*(C`edges()\*(C'\fR.
.SS "\fIis_simple_graph()\fP, \fIis_simple()\fP"
.IX Subsection "is_simple_graph(), is_simple()"
.Vb 3
\&        if ($graph\->is_simple())
\&          {
\&          }
.Ve
.PP
Returns true if the graph does not have multiedges, e.g. if it
does not have more than one edge going from any node to any other
node or group.
.PP
Since this method has to look at all edges, it is costly in terms of
both \s-1CPU\s0 and memory.
.SS "\fIis_directed()\fP"
.IX Subsection "is_directed()"
.Vb 3
\&        if ($graph\->is_directed())
\&          {
\&          }
.Ve
.PP
Returns true if the graph is directed.
.SS "\fIis_undirected()\fP"
.IX Subsection "is_undirected()"
.Vb 3
\&        if ($graph\->is_undirected())
\&          {
\&          }
.Ve
.PP
Returns true if the graph is undirected.
.SS "\fIparent()\fP"
.IX Subsection "parent()"
.Vb 1
\&        my $parent = $graph\->parent();
.Ve
.PP
Returns the parent graph, for graphs this is undef.
.SS "\fIlabel()\fP"
.IX Subsection "label()"
.Vb 1
\&        my $label = $graph\->label();
.Ve
.PP
Returns the label of the graph.
.SS "\fItitle()\fP"
.IX Subsection "title()"
.Vb 1
\&        my $title = $graph\->title();
.Ve
.PP
Returns the (mouseover) title of the graph.
.SS "\fIlink()\fP"
.IX Subsection "link()"
.Vb 1
\&        my $link = $graph\->link();
.Ve
.PP
Return a potential link (for the graphs label), build from the attributes \f(CW\*(C`linkbase\*(C'\fR
and \f(CW\*(C`link\*(C'\fR (or autolink). Returns '' if there is no link.
.SS "\fIas_graphviz()\fP"
.IX Subsection "as_graphviz()"
.Vb 1
\&        print $graph\->as_graphviz();
.Ve
.PP
Return the graph as graphviz code, suitable to be feed to a program like
\&\f(CW\*(C`dot\*(C'\fR etc.
.SS "\fIas_graphviz_file()\fP"
.IX Subsection "as_graphviz_file()"
.Vb 1
\&        print $graph\->as_graphviz_file();
.Ve
.PP
Is an alias for \fIas_graphviz()\fR.
.SS "\fIangle()\fP"
.IX Subsection "angle()"
.Vb 2
\&        my $degrees = Graph::Easy\->angle( \*(Aqsouth\*(Aq );
\&        my $degrees = Graph::Easy\->angle( 120 );
.Ve
.PP
Check an angle for being valid and return a value between \-359 and 359
degrees. The special values \f(CW\*(C`south\*(C'\fR, \f(CW\*(C`north\*(C'\fR, \f(CW\*(C`west\*(C'\fR, \f(CW\*(C`east\*(C'\fR, \f(CW\*(C`up\*(C'\fR
and \f(CW\*(C`down\*(C'\fR are also valid and converted to degrees.
.SS "\fInodes()\fP"
.IX Subsection "nodes()"
.Vb 1
\&        my $nodes = $graph\->nodes();
.Ve
.PP
In scalar context, returns the number of nodes/vertices the graph has.
.PP
In list context, returns all nodes as objects, in arbitrary order.
.SS "\fIanon_nodes()\fP"
.IX Subsection "anon_nodes()"
.Vb 1
\&        my $anon_nodes = $graph\->anon_nodes();
.Ve
.PP
In scalar context, returns the number of anon nodes (aka
Graph::Easy::Node::Anon) the graph has.
.PP
In list context, returns all anon nodes as objects, in arbitrary order.
.SS "\fIhtml_page_header()\fP"
.IX Subsection "html_page_header()"
.Vb 2
\&        my $header = $graph\->html_page_header();
\&        my $header = $graph\->html_page_header($css);
.Ve
.PP
Return the header of an \s-1HTML\s0 page. Used together with html_page_footer
by as_html_page to construct a complete \s-1HTML\s0 page.
.PP
Takes an optional parameter with the \s-1CSS\s0 styles to be inserted into the
header. If \f(CW$css\fR is not defined, embedds the result of \f(CW\*(C`$self\->css()\*(C'\fR.
.SS "\fIhtml_page_footer()\fP"
.IX Subsection "html_page_footer()"
.Vb 1
\&        my $footer = $graph\->html_page_footer();
.Ve
.PP
Return the footer of an \s-1HTML\s0 page. Used together with html_page_header
by as_html_page to construct a complete \s-1HTML\s0 page.
.SS "\fIcss()\fP"
.IX Subsection "css()"
.Vb 1
\&        my $css = $graph\->css();
.Ve
.PP
Return \s-1CSS\s0 code for that graph. See \fIas_html()\fR.
.SS "\fIas_txt()\fP"
.IX Subsection "as_txt()"
.Vb 1
\&        print $graph\->as_txt();
.Ve
.PP
Return the graph as a normalized textual representation, that can be
parsed with Graph::Easy::Parser back to the same graph.
.PP
This does not call \fIlayout()\fR since the actual text representation
is just a dump of the graph.
.SS "\fIas_txt_file()\fP"
.IX Subsection "as_txt_file()"
.Vb 1
\&        print $graph\->as_txt_file();
.Ve
.PP
Is an alias for \fIas_txt()\fR.
.SS "\fIas_svg()\fP"
.IX Subsection "as_svg()"
.Vb 1
\&        print $graph\->as_svg();
.Ve
.PP
Return the graph as \s-1SVG \s0(Scalable Vector Graphics), which can be
embedded into \s-1HTML\s0 pages. You need to install
Graph::Easy::As_svg first to make this work.
.PP
See also \fIas_svg_file()\fR.
.PP
\&\fBNote:\fR You need Graph::Easy::As_svg installed for this to work!
.SS "\fIas_svg_file()\fP"
.IX Subsection "as_svg_file()"
.Vb 1
\&        print $graph\->as_svg_file();
.Ve
.PP
Returns \s-1SVG\s0 just like \f(CW\*(C`as_svg()\*(C'\fR, but this time as standalone \s-1SVG,\s0
suitable for storing it in a file and referencing it externally.
.PP
After calling \f(CW\*(C`as_svg_file()\*(C'\fR or \f(CW\*(C`as_svg()\*(C'\fR, you can retrieve
some \s-1SVG\s0 information, notable \f(CW\*(C`width\*(C'\fR and \f(CW\*(C`height\*(C'\fR via
\&\f(CW\*(C`svg_information\*(C'\fR.
.PP
\&\fBNote:\fR You need Graph::Easy::As_svg installed for this to work!
.SS "\fIsvg_information()\fP"
.IX Subsection "svg_information()"
.Vb 1
\&        my $info = $graph\->svg_information();
\&
\&        print "Size: $info\->{width}, $info\->{height}\en";
.Ve
.PP
Return information about the graph created by the last
\&\f(CW\*(C`as_svg()\*(C'\fR or \f(CW\*(C`as_svg_file()\*(C'\fR call.
.PP
The following fields are set:
.PP
.Vb 2
\&        width           width of the SVG in pixels
\&        height          height of the SVG in pixels
.Ve
.PP
\&\fBNote:\fR You need Graph::Easy::As_svg installed for this to work!
.SS "\fIas_vcg()\fP"
.IX Subsection "as_vcg()"
.Vb 1
\&        print $graph\->as_vcg();
.Ve
.PP
Return the graph as \s-1VCG\s0 text. \s-1VCG\s0 is a subset of \s-1GDL \s0(Graph Description
Language).
.PP
This does not call \fIlayout()\fR since the actual text representation
is just a dump of the graph.
.SS "\fIas_vcg_file()\fP"
.IX Subsection "as_vcg_file()"
.Vb 1
\&        print $graph\->as_vcg_file();
.Ve
.PP
Is an alias for \fIas_vcg()\fR.
.SS "\fIas_gdl()\fP"
.IX Subsection "as_gdl()"
.Vb 1
\&        print $graph\->as_gdl();
.Ve
.PP
Return the graph as \s-1GDL \s0(Graph Description Language) text. \s-1GDL\s0 is a superset
of \s-1VCG.\s0
.PP
This does not call \fIlayout()\fR since the actual text representation
is just a dump of the graph.
.SS "\fIas_gdl_file()\fP"
.IX Subsection "as_gdl_file()"
.Vb 1
\&        print $graph\->as_gdl_file();
.Ve
.PP
Is an alias for \fIas_gdl()\fR.
.SS "\fIas_graphml()\fP"
.IX Subsection "as_graphml()"
.Vb 1
\&        print $graph\->as_graphml();
.Ve
.PP
Return the graph as a GraphML representation.
.PP
This does not call \fIlayout()\fR since the actual text representation
is just a dump of the graph.
.PP
The output contains only the set attributes, e.g. default attribute values
are not specifically mentioned. The attribute names and values are the
in the format that \f(CW\*(C`Graph::Easy\*(C'\fR defines.
.SS "\fIas_graphml_file()\fP"
.IX Subsection "as_graphml_file()"
.Vb 1
\&        print $graph\->as_graphml_file();
.Ve
.PP
Is an alias for \fIas_graphml()\fR.
.SS "\fIsorted_nodes()\fP"
.IX Subsection "sorted_nodes()"
.Vb 6
\&        my $nodes =
\&         $graph\->sorted_nodes( );               # default sort on \*(Aqid\*(Aq
\&        my $nodes = 
\&         $graph\->sorted_nodes( \*(Aqname\*(Aq );        # sort on \*(Aqname\*(Aq
\&        my $nodes = 
\&         $graph\->sorted_nodes( \*(Aqlayer\*(Aq, \*(Aqid\*(Aq ); # sort on \*(Aqlayer\*(Aq, then on \*(Aqid\*(Aq
.Ve
.PP
In scalar context, returns the number of nodes/vertices the graph has.
In list context returns a list of all the node objects (as reference),
sorted by their attribute(s) given as arguments. The default is 'id',
e.g. their internal \s-1ID\s0 number, which amounts more or less to the order
they have been inserted.
.PP
This routine will sort the nodes by their group first, so the requested
sort order will be only valid if there are no groups or inside each
group.
.SS "\fIas_debug()\fP"
.IX Subsection "as_debug()"
.Vb 1
\&        print $graph\->as_debug();
.Ve
.PP
Return debugging information like version numbers of used modules,
and a textual representation of the graph.
.PP
This does not call \fIlayout()\fR since the actual text representation
is more a dump of the graph, than a certain layout.
.SS "\fInode()\fP"
.IX Subsection "node()"
.Vb 1
\&        my $node = $graph\->node(\*(Aqnode name\*(Aq);
.Ve
.PP
Return node by unique name (case sensitive). Returns undef if the node
does not exist in the graph.
.SS "\fIedge()\fP"
.IX Subsection "edge()"
.Vb 1
\&        my $edge = $graph\->edge( $x, $y );
.Ve
.PP
Returns the edge objects between nodes \f(CW$x\fR and \f(CW$y\fR. Both \f(CW$x\fR and \f(CW$y\fR
can be either scalars with names or \f(CW\*(C`Graph::Easy::Node\*(C'\fR objects.
.PP
Returns undef if the edge does not yet exist.
.PP
In list context it will return all edges from \f(CW$x\fR to \f(CW$y\fR, in
scalar context it will return only one (arbitrary) edge.
.SS "\fIid()\fP"
.IX Subsection "id()"
.Vb 2
\&        my $graph_id = $graph\->id();
\&        $graph\->id(\*(Aq123\*(Aq);
.Ve
.PP
Returns the id of the graph. You can also set a new \s-1ID\s0 with this routine. The
default is ''.
.PP
The graph's \s-1ID\s0 is used to generate unique \s-1CSS\s0 classes for each graph, in the
case you want to have more than one graph in an \s-1HTML\s0 page.
.SS "\fIseed()\fP"
.IX Subsection "seed()"
.Vb 2
\&        my $seed = $graph\->seed();
\&        $graph\->seed(2);
.Ve
.PP
Get/set the random seed for the graph object. See \fIrandomize()\fR
for a method to set a random seed.
.PP
The seed is used to create random numbers for the layouter. For
the same graph, the same seed will always lead to the same layout.
.SS "\fIrandomize()\fP"
.IX Subsection "randomize()"
.Vb 1
\&        $graph\->randomize();
.Ve
.PP
Set a random seed for the graph object. See \fIseed()\fR.
.SS "\fIdebug()\fP"
.IX Subsection "debug()"
.Vb 3
\&        my $debug = $graph\->debug();    # get
\&        $graph\->debug(1);               # enable
\&        $graph\->debug(0);               # disable
.Ve
.PP
Enable, disable or read out the debug status. When the debug status is true,
additional debug messages will be printed on \s-1STDERR.\s0
.SS "\fIscore()\fP"
.IX Subsection "score()"
.Vb 1
\&        my $score = $graph\->score();
.Ve
.PP
Returns the score of the graph, or undef if \fIlayout()\fR has not yet been called.
.PP
Higher scores are better, although you cannot compare scores for different
graphs. The score should only be used to compare different layouts of the same
graph against each other:
.PP
.Vb 1
\&        my $max = undef;
\&
\&        $graph\->randomize();
\&        my $seed = $graph\->seed(); 
\&
\&        $graph\->layout();
\&        $max = $graph\->score(); 
\&
\&        for (1..10)
\&          {
\&          $graph\->randomize();                  # select random seed
\&          $graph\->layout();                     # layout with that seed
\&          if ($graph\->score() > $max)
\&            {
\&            $max = $graph\->score();             # store the new max store
\&            $seed = $graph\->seed();             # and it\*(Aqs seed
\&            }
\&          }
\&
\&        # redo the best layout
\&        if ($seed ne $graph\->seed())
\&          {
\&          $graph\->seed($seed);
\&          $graph\->layout();
\&          }
\&        # output graph:
\&        print $graph\->as_ascii();               # or as_html() etc
.Ve
.SS "\fIvalid_attribute()\fP"
.IX Subsection "valid_attribute()"
.Vb 3
\&        my $graph = Graph::Easy\->new();
\&        my $new_value =
\&          $graph\->valid_attribute( $name, $value, $class );
\&
\&        if (ref($new_value) eq \*(AqARRAY\*(Aq && @$new_value == 0)
\&          {
\&          # throw error
\&          die ("\*(Aq$name\*(Aq is not a valid attribute name for \*(Aq$class\*(Aq")
\&                if $self\->{_warn_on_unused_attributes};
\&          }
\&        elsif (!defined $new_value)
\&          {
\&          # throw error
\&          die ("\*(Aq$value\*(Aq is no valid \*(Aq$name\*(Aq for \*(Aq$class\*(Aq");
\&          }
.Ve
.PP
Deprecated, please use \fIvalidate_attribute()\fR.
.PP
Check that a \f(CW\*(C`$name,$value\*(C'\fR pair is a valid attribute in class \f(CW$class\fR,
and returns a new value.
.PP
It returns an array ref if the attribute name is invalid, and undef if the
value is invalid.
.PP
The return value can differ from the passed in value, f.i.:
.PP
.Vb 1
\&        print $graph\->valid_attribute( \*(Aqcolor\*(Aq, \*(Aqred\*(Aq );
.Ve
.PP
This would print '#ff0000';
.SS "\fIvalidate_attribute()\fP"
.IX Subsection "validate_attribute()"
.Vb 3
\&        my $graph = Graph::Easy\->new();
\&        my ($rc,$new_name, $new_value) =
\&          $graph\->validate_attribute( $name, $value, $class );
.Ve
.PP
Checks a given attribute name and value (or values, in case of a
value like \*(L"red|green\*(R") for being valid. It returns a new
attribute name (in case of \*(L"font-color\*(R" => \*(L"fontcolor\*(R") and
either a single new attribute, or a list of attribute values
as array ref.
.PP
If \f(CW$rc\fR is defined, it is the error number:
.PP
.Vb 4
\&        1                       unknown attribute name
\&        2                       invalid attribute value
\&        4                       found multiple attributes, but these arent
\&                                allowed at this place
.Ve
.SS "\fIcolor_as_hex()\fP"
.IX Subsection "color_as_hex()"
.Vb 4
\&        my $hexred   = Graph::Easy\->color_as_hex( \*(Aqred\*(Aq );
\&        my $hexblue  = Graph::Easy\->color_as_hex( \*(Aq#0000ff\*(Aq );
\&        my $hexcyan  = Graph::Easy\->color_as_hex( \*(Aq#f0f\*(Aq );
\&        my $hexgreen = Graph::Easy\->color_as_hex( \*(Aqrgb(0,255,0)\*(Aq );
.Ve
.PP
Takes a valid color name or definition (hex, short hex, or \s-1RGB\s0) and returns the
color in hex like \f(CW\*(C`#ff00ff\*(C'\fR.
.ie n .SS "color_value($color_name, $color_scheme)"
.el .SS "color_value($color_name, \f(CW$color_scheme\fP)"
.IX Subsection "color_value($color_name, $color_scheme)"
.Vb 2
\&        my $color = Graph::Easy\->color_name( \*(Aqred\*(Aq );   # #ff0000
\&        print Graph::Easy\->color_name( \*(Aq#ff0000\*(Aq );     # #ff0000
\&
\&        print Graph::Easy\->color_name( \*(Aqsnow\*(Aq, \*(Aqx11\*(Aq );
.Ve
.PP
Given a color name, returns the color in hex. See color_name
for a list of possible values for the optional \f(CW$color_scheme\fR
parameter.
.ie n .SS "color_name($color_value, $color_scheme)"
.el .SS "color_name($color_value, \f(CW$color_scheme\fP)"
.IX Subsection "color_name($color_value, $color_scheme)"
.Vb 2
\&        my $color = Graph::Easy\->color_name( \*(Aqred\*(Aq );   # red
\&        print Graph::Easy\->color_name( \*(Aq#ff0000\*(Aq );     # red
\&
\&        print Graph::Easy\->color_name( \*(Aqsnow\*(Aq, \*(Aqx11\*(Aq );
.Ve
.PP
Takes a hex color value and returns the name of the color.
.PP
The optional parameter is the color scheme, where the following
values are possible:
.PP
.Vb 2
\& w3c                    (the default)
\& x11                    (what graphviz uses as default)
.Ve
.PP
Plus the following ColorBrewer schemes are supported, see the
online manual for examples and their usage:
.PP
.Vb 1
\& accent3 accent4 accent5 accent6 accent7 accent8
\&
\& blues3 blues4 blues5 blues6 blues7 blues8 blues9
\&
\& brbg3 brbg4 brbg5 brbg6 brbg7 brbg8 brbg9 brbg10 brbg11
\&
\& bugn3 bugn4 bugn5 bugn6 bugn7 bugn8 bugn9 bupu3 bupu4 bupu5 bupu6 bupu7
\& bupu8 bupu9
\&
\& dark23 dark24 dark25 dark26 dark27 dark28
\&
\& gnbu3 gnbu4 gnbu5 gnbu6 gnbu7 gnbu8 gnbu9
\&
\& greens3 greens4 greens5 greens6 greens7 greens8 greens9
\&
\& greys3 greys4 greys5 greys6 greys7 greys8 greys9
\&
\& oranges3 oranges4 oranges5 oranges6 oranges7 oranges8 oranges9
\&
\& orrd3 orrd4 orrd5 orrd6 orrd7 orrd8 orrd9
\&
\& paired3 paired4 paired5 paired6 paired7 paired8 paired9 paired10 paired11
\& paired12 pastel13 pastel14 pastel15 pastel16 pastel17 pastel18 pastel19
\&
\& pastel23 pastel24 pastel25 pastel26 pastel27 pastel28
\&
\& piyg3 piyg4 piyg5 piyg6 piyg7 piyg8 piyg9 piyg10 piyg11
\&
\& prgn3 prgn4 prgn5 prgn6 prgn7 prgn8 prgn9 prgn10 prgn11
\&
\& pubu3 pubu4 pubu5 pubu6 pubu7 pubu8 pubu9
\&
\& pubugn3 pubugn4 pubugn5 pubugn6 pubugn7 pubugn8 pubugn9
\&
\& puor3 puor4 puor5 puor6 puor7 puor8 puor9 purd3 purd4 purd5 purd6 purd7 purd8
\& purd9 puor10 puor11
\&
\& purples3 purples4 purples5 purples6 purples7 purples8 purples9
\&
\& rdbu10 rdbu11 rdbu3 rdbu4 rdbu5 rdbu6 rdbu7 rdbu8 rdbu9 rdgy3 rdgy4 rdgy5 rdgy6
\&
\& rdgy7 rdgy8 rdgy9 rdpu3 rdpu4 rdpu5 rdpu6 rdpu7 rdpu8 rdpu9 rdgy10 rdgy11
\&
\& rdylbu3 rdylbu4 rdylbu5 rdylbu6 rdylbu7 rdylbu8 rdylbu9 rdylbu10 rdylbu11
\&
\& rdylgn3 rdylgn4 rdylgn5 rdylgn6 rdylgn7 rdylgn8 rdylgn9 rdylgn10 rdylgn11
\&
\& reds3 reds4 reds5 reds6 reds7 reds8 reds9
\&
\& set13 set14 set15 set16 set17 set18 set19 set23 set24 set25 set26 set27 set28
\& set33 set34 set35 set36 set37 set38 set39
\&
\& set310 set311 set312
\&
\& spectral3 spectral4 spectral5 spectral6 spectral7 spectral8 spectral9
\& spectral10spectral11
\&
\& ylgn3 ylgn4 ylgn5 ylgn6 ylgn7 ylgn8 ylgn9
\&
\& ylgnbu3 ylgnbu4 ylgnbu5 ylgnbu6 ylgnbu7 ylgnbu8 ylgnbu9
\&
\& ylorbr3 ylorbr4 ylorbr5 ylorbr6 ylorbr7 ylorbr8 ylorbr9
\&
\& ylorrd3 ylorrd4 ylorrd5 ylorrd6 ylorrd7 ylorrd8 ylorrd9
.Ve
.SS "\fIcolor_names()\fP"
.IX Subsection "color_names()"
.Vb 1
\&        my $names = Graph::Easy\->color_names();
.Ve
.PP
Return a hash with name => value mapping for all known colors.
.SS "\fItext_style()\fP"
.IX Subsection "text_style()"
.Vb 4
\&        if ($graph\->text_style(\*(Aqbold, italic\*(Aq))
\&          {
\&          ...
\&          }
.Ve
.PP
Checks the given style list for being valid.
.SS "\fItext_styles()\fP"
.IX Subsection "text_styles()"
.Vb 1
\&        my $styles = $graph\->text_styles();     # or $edge\->text_styles() etc.
\&
\&        if ($styles\->{\*(Aqitalic\*(Aq})
\&          {
\&          print \*(Aqis italic\en\*(Aq;
\&          }
.Ve
.PP
Return a hash with the given text-style properties, aka 'underline', 'bold' etc.
.SS "\fItext_styles_as_css()\fP"
.IX Subsection "text_styles_as_css()"
.Vb 1
\&        my $styles = $graph\->text_styles_as_css();      # or $edge\->...() etc.
.Ve
.PP
Return the text styles as a chunk of \s-1CSS\s0 styling that can be embedded into
a \f(CW\*(C` style="" \*(C'\fR parameter.
.SS "\fIuse_class()\fP"
.IX Subsection "use_class()"
.Vb 1
\&        $graph\->use_class(\*(Aqnode\*(Aq, \*(AqGraph::Easy::MyNode\*(Aq);
.Ve
.PP
Override the class to be used to constructs objects when calling
\&\f(CW\*(C`add_edge()\*(C'\fR, \f(CW\*(C`add_group()\*(C'\fR or \f(CW\*(C`add_node()\*(C'\fR.
.PP
The first parameter can be one of the following:
.PP
.Vb 3
\&        node
\&        edge
\&        group
.Ve
.PP
Please see the documentation about \f(CW\*(C`use_class()\*(C'\fR in \f(CW\*(C`Graph::Easy::Parser\*(C'\fR
for examples and details.
.SS "\fIanimation_as_graph()\fP"
.IX Subsection "animation_as_graph()"
.Vb 2
\&        my $graph_2 = $graph\->animation_as_graph();
\&        print $graph_2\->as_ascii();
.Ve
.PP
Returns the animation of \f(CW$graph\fR as a graph describing the flow of the
animation. Useful for debugging animation flows.
.SS "\fIadd_cycle()\fP"
.IX Subsection "add_cycle()"
.Vb 1
\&        $graph\->add_cycle(\*(AqA\*(Aq,\*(AqB\*(Aq,\*(AqC\*(Aq);         # A \-> B \-> C \-> A
.Ve
.PP
Compatibility method for Graph, adds the edges between each node
and back from the last node to the first. Returns the graph.
.SS "\fIadd_path()\fP"
.IX Subsection "add_path()"
.Vb 1
\&        $graph\->add_path(\*(AqA\*(Aq,\*(AqB\*(Aq,\*(AqC\*(Aq);          # A \-> B \-> C
.Ve
.PP
Compatibility method for Graph, adds the edges between each node.
Returns the graph.
.SS "\fIadd_vertex()\fP"
.IX Subsection "add_vertex()"
.Vb 1
\&        $graph\->add_vertex(\*(AqA\*(Aq);
.Ve
.PP
Compatibility method for Graph, adds the node and returns the graph.
.SS "\fIadd_vertices()\fP"
.IX Subsection "add_vertices()"
.Vb 1
\&        $graph\->add_vertices(\*(AqA\*(Aq,\*(AqB\*(Aq);
.Ve
.PP
Compatibility method for Graph, adds these nodes and returns the graph.
.SS "\fIhas_edge()\fP"
.IX Subsection "has_edge()"
.Vb 1
\&        $graph\->has_edge(\*(AqA\*(Aq,\*(AqB\*(Aq);
.Ve
.PP
Compatibility method for Graph, returns true if at least one edge between
A and B exists.
.SS "\fIvertices()\fP"
.IX Subsection "vertices()"
Compatibility method for Graph, returns in scalar context the number
of nodes this graph has, in list context a (arbitrarily sorted) list
of node objects.
.SS "\fIset_vertex_attribute()\fP"
.IX Subsection "set_vertex_attribute()"
.Vb 1
\&        $graph\->set_vertex_attribute( \*(AqA\*(Aq, \*(Aqfill\*(Aq, \*(Aq#deadff\*(Aq );
.Ve
.PP
Compatibility method for Graph, set the named vertex attribute.
.PP
Please note that this routine will only accept Graph::Easy attribute
names and values. If you want to attach custom attributes, you need to
start their name with 'x\-':
.PP
.Vb 1
\&        $graph\->set_vertex_attribute( \*(AqA\*(Aq, \*(Aqx\-foo\*(Aq, \*(Aqbar\*(Aq );
.Ve
.SS "\fIget_vertex_attribute()\fP"
.IX Subsection "get_vertex_attribute()"
.Vb 1
\&        my $fill = $graph\->get_vertex_attribute( \*(AqA\*(Aq, \*(Aqfill\*(Aq );
.Ve
.PP
Compatibility method for Graph, get the named vertex attribute.
.PP
Please note that this routine will only accept Graph::Easy attribute
names. See \fIset_vertex_attribute()\fR.
.SH "EXPORT"
.IX Header "EXPORT"
Exports nothing.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Graph, Graph::Convert, Graph::Easy::As_svg, Graph::Easy::Manual and
Graph::Easy::Parser.
.SS "Related Projects"
.IX Subsection "Related Projects"
Graph::Layout::Aesthetic, Graph and Text::Flowchart.
.PP
There is also an very old, unrelated project from ca. 1995, which does something similar.
See <http://rw4.cs.uni\-sb.de/users/sander/html/gsvcg1.html>.
.PP
Testcases and more examples under:
.PP
<http://bloodgate.com/perl/graph/>.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
This module is now quite complete, but there are still some limitations.
Hopefully further development will lift these.
.SS "Scoring"
.IX Subsection "Scoring"
Scoring is not yet implemented, each generated graph will be the same regardless
of the random seed.
.SS "Layouter"
.IX Subsection "Layouter"
The layouter can not yet handle links between groups (or between
a group and a node, or vice versa). These links will thus only
appear in \fIas_graphviz()\fR or \fIas_txt()\fR output.
.SS "Paths"
.IX Subsection "Paths"
.IP "No optimizations" 2
.IX Item "No optimizations"
In complex graphs, non-optimal layout part like this one might appear:
.Sp
.Vb 9
\&        +\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-+
\&        | Bonn | \-\-> | Berlin | \-\-> ...
\&        +\-\-\-\-\-\-+     +\-\-\-\-\-\-\-\-+
\&                       ^
\&                       |
\&                       |
\&        +\-\-\-\-\-\-\-\-\-+    |
\&        | Kassel  | \-\-\-+
\&        +\-\-\-\-\-\-\-\-\-+
.Ve
.Sp
A second-stage optimizer that simplifies these layouts is not yet implemented.
.Sp
In addition the general placement/processing strategy as well as the local
strategy might be improved.
.IP "attributes" 2
.IX Item "attributes"
The following attributes are currently ignored by the layouter:
.Sp
.Vb 3
\&        undirected graphs
\&        autosplit/autojoin for edges
\&        tail/head label/title/link for edges
.Ve
.IP "groups" 2
.IX Item "groups"
The layouter is not fully recursive yet, so groups do not properly nest.
.Sp
In addition, links to/from groups are missing, too.
.SS "Output formats"
.IX Subsection "Output formats"
Some output formats are not yet complete in their
implementation. Please see the online manual at
<http://bloodgate.com/perl/graph/manual> under \*(L"Output\*(R" for
details.
.PP

.IX Xref "graph manual online"
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under the terms of the \s-1GPL 2.0\s0 or a later version.
.PP
See the \s-1LICENSE\s0 file for a copy of the \s-1GPL.\s0
.PP
This product includes color specifications and designs developed by Cynthia
Brewer (http://colorbrewer.org/). See the \s-1LICENSE\s0 file for the full license
text that applies to these color schemes.
.PP

.IX Xref "gpl apache-style cynthia brewer colorscheme license"
.SH "NAME CHANGE"
.IX Header "NAME CHANGE"
The package was formerly known as \f(CW\*(C`Graph::Simple\*(C'\fR. The name was changed
for two reasons:
.IP "\(bu" 2
In graph theory, a \f(CW\*(C`simple\*(C'\fR graph is a special type of graph. This software,
however, supports more than simple graphs.
.IP "\(bu" 2
Creating graphs should be easy even when the graphs are quite complex.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 2004 \- 2008 by Tels <http://bloodgate.com>
.PP

.IX Xref "tels"
